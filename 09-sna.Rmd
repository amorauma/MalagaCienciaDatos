```{r, warning=FALSE, message=FALSE}
library(knitr)
library(kableExtra)
options(knitr.table.format = "html") 
library(igraph)
library(igraphdata)
library(tidyverse)
```

# Social Network Analysis

-   **Disciplina con base sólida de Matemática Aplicada: Teoría de Grafos y Matemática Discreta.**

-   Unida con Álgebra Lineal: las bases de Pagerank (algoritmo de Google) [The Mathematics of Google Search](http://pi.math.cornell.edu/~mec/Winter2009/RalucaRemus/Lecture3/lecture3.html).

Describir las relaciones entre los elementos de una red y extraer conocimiento acerca de las estructuras sociales que existen en esa red. Tópico de enorme interés para extraer conocimiento de redes sociales **en cualquier área**.

> > en una red los actores no intervienen aislados

> > decribir todos los actores intervinientes en las redes

> > redes de alta complejidad

Existen muy destacadas aplicaciones para SNA:

-   Gephi

    -   <https://gephi.org>

    -   <https://gephi.org/tutorials/gephi-tutorial-quick_start.pdf>

    > Exploratory Data Analysis: intuition-oriented analysis by networks manipulations in real time.

    > Link Analysis: revealing the underlying structures of associations between objects.

    > Social Network Analysis: easy creation of social data connectors to map community organizations and small-world networks.

    > Biological Network analysis: representing patterns of biological data.

-   Cytoscape

-   <https://cytoscape.org>

    > Cytoscape is an open source software platform for visualizing molecular interaction networks and biological pathways and integrating these networks with annotations, gene expression profiles and other state data.

    > Library for visualization

## R for SNA

Usaremos el paquete **igraph**. Nos servirá para analizar más adelante datos extraído de Twiter.

Ventajas de usar R:

-   **Reproducible research** no es posible con las aplicaciones GUI.

-   Herramientas sólidas para manipular los datos.

-   Cada vez más paquetes diseñados para hacer de R una herramienta completa de análisis de redes.

-   Paquetes statnet y igraph.

-   Thomas Lin Pedersen ha publicado los paquetes tidygraph y ggraph, que aprovechan la potencia de igraph de forma coherente con el flujo de trabajo de tidyverse.

-   Crear gráficos de red interactivos con el marco htmlwidgets que traduce el código de R a JavaScript.

### Elementos de una red

-   nodos o vértices de grafo (nodes, vertices)

```{r,echo=FALSE}
pel <- read.csv("data/peliculas.csv")
 
unique(c(pel$Actor.1,pel$Actor.2 ))

```

-   arcos o enlaces (edges, links)

```{r,echo=FALSE}
  
cbind(pel$Actor.1, pel$Actor.2)

```

Nodos y arcos pueden contender atributos adicionales con importante información:

```{r,echo=FALSE}
grafo_peliculas <- graph.edgelist(as.matrix(pel[,c(1,2)]),directed = FALSE)

E(grafo_peliculas)$movies <- pel$Movie

E(grafo_peliculas)$movies
grafo_peliculas$layout <- layout_in_circle
 
 
plot(grafo_peliculas,vertex.size = 1, 
     vertex.color = "blue", 
     vertex.label.color = "black",  
     vertex.label.dist = 1,
     edge.label = E(grafo_peliculas)$movies,
     edge.label.cex = 0.5,
     edge.label.font =1,
     edge.arrow.size=0.4,
     edge.curved=0.3)

 
```

### Representación de redes

#### Grafos como listas de arcos

data.frame o matriz (si los datos del mismo tipo) que contiene dos columnas:

-   primera columna: nodos que son el origen de una conexión
-   segunda columna: nodos que son el destino de la conexión

Si el sentido es importante, la red se denomina dirigida, en otro caso, no dirigida.

```{r,echo=TRUE,eval=TRUE}
alumnos1 <- c("Luis", "Ana", "Fran", "Pedro", "Laura", "Susana")
alumnos2 <- c("Juan", "Jose", "Amalia", "Lucía", "Maite", "Eduardo")

grupos <- data.frame(integrante1 = alumnos1, integrante2 = alumnos2, stringsAsFactors = F)

print(grupos)
str(grupos)

```

#### Grafos como matrices

```{r,echo=TRUE,eval=TRUE}
# Se pueden usar matrices 'sparse'
A <- rbind(c(0,1,0), c(1,0,1), c(1,0,0))
nodeNames <-  c("A","B","C")
dimnames(A) <-  list(nodeNames, nodeNames)
A
str(A)

```

> Caminos de longitud dos, tres, etc:

```{r,echo=TRUE,eval=TRUE}
# Multiplicación matricial
A2 <- A %*% A
A2

A3 <- A %*% A %*% A 
A3
```

> Representado arcos:

```{r,echo=TRUE,eval=TRUE}
Arcos <- rbind(c("A","B"), c("B","A"), c("B","C"), c("C","A"))
Arcos
```

<!-- ### Usando tidverse -->

<!-- ```{r,echo=TRUE,eval=TRUE} -->

<!-- alumnos1 <- c("Luis", "Ana", "Fran", "Pedro", "Laura", "Susana") -->

<!-- alumnos2 <- c("Juan", "Jose", "Amalia", "Lucía", "Maite", "Eduardo") -->

<!-- node_list_alumnos <- tibble(id = unique(c(alumnos1,alumnos2))) -->

<!-- node_list_alumnos -->

<!-- edge_list_alumnos <- tibble(from = alumnos1, to = alumnos2) -->

<!-- edge_list_alumnos -->

<!-- ``` -->

## `igraph`

```{r,echo=TRUE,eval=TRUE}
# Instalar la primera vez - descomentar
#install.packages("igraph")
#install.packages("igraphdata")
library(igraph)
library(igraphdata)


# Importar la red de datasets ya establecidos: igraphdata

# Limpia la memoria - Cuidado - borra todas las variables
rm(list=ls())

#Lista de datasets de redes de nodos en igraph
# data(package="igraphdata") 
 
# El paquete tiene un conjunto de datasets
# Carga data set y vemos que contiene 
#Red social entre miembros de club de karate de universidad 
data(karate,package="igraphdata") 
plot(karate)
```

### Acceder a elementos de grado

```{r}
# UKfaculty: Friendship network of a UK university faculty
data(UKfaculty) 
plot(UKfaculty)
UKfaculty
V(UKfaculty)
E(UKfaculty)
V(UKfaculty)
str(UKfaculty)
head(E(UKfaculty)$weight)
head(V(UKfaculty)$Group)
```

### Construir/Modificar un grafo

> Añadir arcos a un grafo vacío:

```{r,echo=TRUE,eval=TRUE}
# Un grafo dirigido  vacío  
g <- make_empty_graph(n = 0, directed = TRUE)
g
g <- g + vertices(c("A","B","C"))
g

# Arcos:  A to C ,  B to C
g <- g + edges(c("A","C", "B","C")) 
g

# Eliminar arco  A
g <- g - V(g)["A"]
g
# Eliminará todos los arcos conectados con A
```

> Lista de arcos: graph() and get.edgelist():

```{r,echo=TRUE,eval=TRUE}
# Un grafo dirigido  vacío  

#     graph() id desde   1. 
g1 <- graph( c(1,2, 1,3, 2,3, 3,4 ));g1
summary(g1)
plot(g1)

# El parámetro "directed" a  FALSE para
# grafos no dirigidos.  

g2 <- graph( c(1,2, 1,3, 2,3, 3,4 , 3, 5, 1, 3), directed=FALSE); g2 
summary(g2)
plot(g2)

#Obtener la lista de arcos a partir de un grafo   
edgelist<-get.edgelist(g2) ; edgelist
edgelist <- as_edgelist(g2) ; edgelist

# Obtener el grafo a partir de la lista de arcos
g3<-graph( t(edgelist));  g3;  plot(g3)
g3<-graph( edgelist);  g3;  plot(g3)

# algunos parámetros de plot 

plot(g3, 
     vertex.color="green", 
     edge.arrow.size=0.5, 
     vertex.size=25,
     edge.curved=0.5,
     layout_as_star=TRUE)
```

> Matrices de adyacencia: graph.adjacency(), get.adjacency()

```{r,echo=TRUE,eval=TRUE}
adjm_u<-matrix(
  c(0, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 
  0, 1, 0, 1, 0, 0, 
  0, 0, 1, 0, 1, 1, 
  1, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0),
  nrow=6, 
  ncol=6, 
  byrow = TRUE)
#grafo a partir de matriz de adyacencia
g_adj_u <- graph.adjacency(adjm_u, mode="undirected") 

plot(g_adj_u)
# Matriz de adyacencia a partir de grafo
A <- get.adjacency(g_adj_u); A
A <- as_adjacency_matrix(g_adj_u, sparse = FALSE)
A

```

> Grafo a partir de data frame

```{r,echo=TRUE,eval=TRUE}
# Primero, crear el data frame
node1 = c("Ella", "Tu", "El"); node2 = c("El", "Ella", "Tu")
weight = c(10, -2, 3)
df = data.frame(node1, node2, weight); df
# Crear el grafo 
g <- graph.data.frame(df, directed=FALSE); g
plot(g)
# Si se conocen los vértices
# g <- graph.data.frame(df, vertices=listvertices, directed=FALSE);g

# Obtener los nombres de los nodos
V(g)$name 

# Obtener los pesos de los arcos
E(g)$weight  
 


```

> Grafo a partir de literales

```{r,echo=TRUE,eval=TRUE}
#?graph_from_literal

g <- graph_from_literal(A--C, A-+D, C-+A, , D-+C)
g
plot(g)

#IGRAPH DN-- 4 4 -- 
#+ attr: name (v/c)
#+ edges (vertex names):
#[1] A->D D->C D->B B->A

 G3 <-graph_from_literal(A-B, B -+C)
 plot(G3)
 G3 <-graph_from_literal(A-B, B -C)
 plot(G3)

```

> > grafo aleatorio

```{r}
g_random <- sample_gnp(10, 0.2, directed = FALSE, loops = FALSE)
plot(g_random)
```

### Visualización

Buscar ayuda de los comandos **plot.igraph**, **igraph.plotting**.

A continuación dibujamos algunos grafos interesantes:

```{r,echo=TRUE,eval=TRUE}
#library(igraph)
# Trees
g <- make_tree(27, children=3)
g; plot(g)

# Cliques 
g <- make_full_graph(n=6)
g; plot(g)

# Lattices
g <- make_lattice(dimvector = c(5,5), circular = FALSE)
V(g)$label <- NA
g; plot(g)

#Stars
g <- make_star(n=10,mode = "undirected")
g;  plot(g)


```

> Anillo con conexiones cruzadas:

```{r,echo=TRUE,eval=TRUE}
g <- make_ring(10, directed=TRUE, mutual=TRUE)

V(g)$name <- LETTERS[1:10]

g <-  g + edges(9,5, 7,1, 1,5)

plot(g)

```

### Layout

Un *layout* es un conjunto de coordenadas x,y preestablecidas. Se pueden especificar manualmente o usando **layout_functions**

> > Determina la posición de los nodos en la red. Hay layouts ya diseñados o puedes diseñarlo desde 0.

> > Intentar minimizar cruces de arcos.

> > Algoritmos que lo consiguen: por ejemplo - Kamada Kawai algorithm, the Fruchterman Reingold algorithm, etc.

```{r,echo=TRUE,eval=TRUE}

Lykamada <- layout.kamada.kawai(g)
plot(g, layout=Lykamada)

Lyfruchtermant <- layout.fruchterman.reingold(g)
plot(g, layout=Lyfruchtermant)

lo <- layout_in_circle(g)
head(lo, n=4) 

# lo es una matriz de coordenadas  
lo
plot(g, layout=lo)

# See ?layout_ for a full list

# Para redes tipo árbol:  layout_as_tree
gTree <- make_tree(15)
plot(gTree, layout=layout_as_tree(gTree, root = 1))

# layout como un grid
plot(g, layout=layout_on_grid(g))
```

Mallas:

```{r}
library(igraph)
#Buscar en ayuda
#?igraph::layout  
g <- make_tree(15)
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g)
plot(g, layout=layout1)


# Otra malla diferente
plot(g, layout=layout.kamada.kawai)
# Malla interactiva - Ejecutar en consola
# tkplot(g, layout=layout.kamada.kawai)
```

### Dibujar grafos ponderados

```{r, eval=FALSE}
V(g)$label.cex <- ...
V(g)$label.color <- ...
V(g)$frame.color <- ... 
E(g)$color <- rgb(....
E(g)$width <-    
  
```

### Cambiar aspecto y propiedades de un grafo

    V(g)$shape 
    V(g)$size
    V(g)$color

-   vertex.shape
-   vertex.color
-   vertex.size\
-   set_edge_attr
-   set_vertex_attr
-   set_graph_attr

```{r}
plot(g, vertex.size = 20)
plot(g, vertex.size = 10, vertex.color = "blue", vertex.frame.color = NA, vertex.label = NA)
plot(g, vertex.size = 10, vertex.color = "blue", vertex.frame.color = NA, vertex.label.cex = .7,  vertex.label = NA, edge.curved = .5, edge.arrow.size = .3, edge.width = .7)
```

Note: colores en R <http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf>

```{r}
library(tidyverse)
g1random <- sample_gnp(10, p=0.4)

V(g1random)[1]$color <- "yellow" 

g1random %>%
  set_edge_attr("color",value = "blue") %>%
 plot()
```

### Ejemplos - plantillas

> Plot vocales como rectángulos

```{r,echo=TRUE,eval=TRUE}
g <- make_ring(10, directed=TRUE, mutual=TRUE)

V(g)$name <- LETTERS[1:10]

g <-  g + edges(9,5, 7,1, 1,5)

plot(g)
vowel <- V(g)$name %in% c("A","E","I","O","U") + 1 # gives 1 or 2
plot(g, layout=lo, vertex.shape=c("circle", "square")[vowel])
#colores
plot(g, layout=lo, vertex.color=c("tomato2", "royalblue")[vowel])
#tamaño
plot(g, layout=lo, vertex.size=c(15,30)[vowel])
#Propiedades usando atributos

V(g)$shape <- "circle" # Aplicado a todos los vértices
V(g)$size <- 15
V(g)$color <- "orange"
isVowel <- V(g)$name %in% c("A","E","I","O","U")
# Sobreescribir los nodos vocales 
V(g)[isVowel]$shape <- "square"
V(g)[isVowel]$color <- "royalblue"
V(g)[isVowel]$size <- 25

plot(g, layout=lo)

```

> Propiedades de los arcos

```{r,echo=TRUE,eval=TRUE}
E(g)$width <- 1
v1 <-V(g)[isVowel]
v1
E(g)[v1  %--%  v1]$width <- 4

# Ver http://igraph.org/r/doc/igraph-es-indexing.html

plot(g, layout=lo)

#Arcos curvados
plot(g, layout=lo, edge.curved=0.3*which_mutual(g))

```

> Agrupaciones por índices:

```{r,echo=TRUE,eval=TRUE}
groupList <- list(vowelGroup = which(isVowel),
                  constGroup1 = c(2,3,4),
                  constGroup2 = c(6,7,8))

groupColours <- c(rgb(0,0.3,1,0.5),
                  rgb(0.8,0.4,0.1,0.5),
                  rgb(0.8,0.4,0.1,0.5))
plot(g, layout=layout_with_fr, # Fruchterman?Reingold layout
     mark.groups=groupList, # Mark the groups
     mark.col= groupColours,
     # Eliminar el borde
     mark.border = NA, 
     edge.curved=0.1*which_mutual(g))
text(0.45,0.1,"Vocales", cex=1.5)
text(0.5,0.9,"Grupo consonantes 1", cex=1.5)
text(-0.8,-1,"Grupo consonantes 2", cex=1.5)

```

## Exportar grafos

**igraph** permite importar y exportar de/desde un considerable número de formatos. Se usan los comandos **read_graph** y **write_graph**. Un formato abierto (open) es *graphml*.

```{r,echo=TRUE,eval=TRUE}
write_graph(g, "gr1.graphml", format="graphml")

```

Otros formatos:

-   edgelist: Fichero de texto con arcos en cada línea.

-   pajek: Pajek es un programa popular en Windows para análisis de redes.\

-   gml: Graph Modelling Language es uno de los formatos abiertos más populares.\

-   graphml: Graph Markup Language es un formato abierto basado en XML.

-   dot: Formato usado por GraphViz.

-   \*\* Gephi: Para exportar al formato nativo GEXF de Gephise usa el paquete rgexf al que puede convertirse desde un objeto igraph \*\*

Referencias:

-   <https://www.r-project.org/nosvn/conferences/useR-2010/slides/Zhang.pdf>
-   <https://programminghistorian.org/en/lessons/temporal-network-analysis-with-r>

## De Twitter

-   El primer paso será extraer los términos usando las técnicas de text mining y crear una matriz de términos (DTM - Document Term Matrix:).
-   Los documentos serían los tweets y los términos serían las palabras o grupos de palabras destacadas en los datos extraidos.
-   **Objetivo: Construir una red de términos (personas) basada en sus co-ocurrencias en los mismos tweets (pertenencia a los mismos grupos)**.

## Medidas de bondad, calidad

Analysis of the Networks to extract knowledge.

\>\> Goal of a SNA proyect

\[[http://snap.stanford.edu/class/cs224w-2015/slides/06-applicationsI.pdf\](http://snap.stanford.edu/class/cs224w-2015/slides/06-applicationsI.pdf)](http://snap.stanford.edu/class/cs224w-2015/slides/06-applicationsI.pdf](http://snap.stanford.edu/class/cs224w-2015/slides/06-applicationsI.pdf))

\* Locate people in the network for...

1. higher compensation

2. positive performance evaluations

3. more promotions

4. more good ideas

\> Ego network is a special type of network consisting of one central node and all other nodes directly connected to it. The central node is known as ego, while the other surrounding nodes directly connected to it are known as alters.

\* \[[https://medium.com/applied-data-science/the-google-vs-trick-618c8fd5359f\](https://medium.com/applied-data-science/the-google-vs-trick-618c8fd5359f)](https://medium.com/applied-data-science/the-google-vs-trick-618c8fd5359f](https://medium.com/applied-data-science/the-google-vs-trick-618c8fd5359f))

\* \[[http://olizardo.bol.ucla.edu/classes/soc-111/lessons-winter-2022/5-lesson-egonet-metrics.html\](http://olizardo.bol.ucla.edu/classes/soc-111/lessons-winter-2022/5-lesson-egonet-metrics.html)](http://olizardo.bol.ucla.edu/classes/soc-111/lessons-winter-2022/5-lesson-egonet-metrics.html](http://olizardo.bol.ucla.edu/classes/soc-111/lessons-winter-2022/5-lesson-egonet-metrics.html))

Vamos a usar este grafo como ejemplo de las medidas de bondad del grafo.

\`\`\`{r}

library(igraph)

g1 \<- graph( c(1,2, 1,3, 2,3,

3,4, 3,5, 1,5,

4,2, 3,6, 4,8,

8,1, 9,1, 10,2,

7,6, 5,10))

g1

summary(g1)

plot(g1)

\`\`\`

\*\*Vértices, arcos\*\*.

\`\`\`{r}

class(g1)

V(g1)

V(g1)\[1\]

E(g1)

E(g1)\[1\]

class(V(g1))

class(E(g1))

\`\`\`

### Centrality

Importancia de los nodos en un grafo.

\- Número de arcos de entrada-salida de los nodos.

\- Redes con alta centralidad tienen pocos nodos con muchas conexiones.

\- Redes con baja centralidad tienen muchos nodos con similar o menos conexiones.

\- Ver <https://en.wikipedia.org/wiki/Centrality#PageRank_centrality>

### Degree

Número de arcos conectados a un vértice. Señala la importancia de un vértice o el nivel de actividad del vértice en la red.

\- Cómo de central es un nodo en la red

\- Cuántos arcos de entrada-salida tiene o con cuántos nodos se conecta directamente via un arco.

\> \> \`centr_degree\`, \`igraph::degree\`

\`\`\`{r}

g1

plot(g1)

igraph::degree(g1)

igraph::degree(g1, mode="in")

igraph::degree(g1, mode="out")

deg \<- centr_degree(g1)

deg

\`\`\`

### Betweenness

Mide el grado en el que la información fluye a través de un vértice particular y su importancia relativa como un intermediario en la red.

Describe nodos que son conexiones clave o puentes entre grupos de nodos.

\- El número de caminos más cortos que pasan por un nodo dado (medida relativa) - la suma de las longitudes de los caminos más cortos entre otros nodos pasando por el nodo, dividida por las longitudes de camino más cortas (no necesariamente a través del nodo) entre los otros nodos.

\> \> \`igraph::betweenness\`

\`\`\`{r}

igraph::betweenness(g1)

\`\`\`

\- Por el vértice 6 no pasa ningún \*camino más corto\* entre dos vértices.

\- Por el vértice 3 pasan 25 \*caminos más cortos\* entre dos vértices.

\- ...

### Edge_betweenness

Similar al anterior pero teniendo en cuenta cada arco.

\> \> \`igraph::edge_betweenness\`

\`\`\`{r}

g1 \<- set.edge.attribute(g1, "weight", value= 1)

bg \<- edge_betweenness(g1)

plot(g1, edge.label = bg)

\`\`\`

### Closeness

Distancia a otros nodos. Un nodo con valor alto de este estimador es más central y puede difundir la información a muchos otros nodos.

\- Se obtiene como 1 divido por la suma de las distancias geodésicas desde un vértice al resto. Alcanzará su valor máximo cuando un vértice esté conectado a todos los demás. Longitud media de los caminos más cortos (geodésicos).

\- Mide cuantos pasos se requieren desde un vértice para alcanzar el resto de vértices de la red.

\- Caminos cortos entre vértices señalan que estos están cercanos unos a otros.

\> \> \`centr_clo\`, \`igraph::closeness\`

\`\`\`{r}

igraph::closeness(g1)

\`\`\`

### Eigenvector

No todas las conexiones tienen la misma importancia - medida de la importancia de un nodo.

\- La medida \*Eigenvector Centrality\* se calcula como el autovalor de mayor módulo de la matriz de adyacencia que contiene los pesos.

\- \*a high score to vertices that either have a lot of connections, or are connected to someone with a lot of connections\*

\> \> Eigenvector Centrality: \`eigen_centrality\`

\`\`\`{r}

eigen_centrality(g1)

\`\`\`

### Pagerank

Algoritmo de Google para realizar un ranking con la importancia de los resultados de la búsqueda.

Nodos son más importantes si tienen muchos enlaces de entrada.

\> \> \`page.rank\`

\`\`\`{r}

page.rank(g1)

\`\`\`

\# Paths

Caminos de un vértice a otro o de grupos de vértices a otros.

### Diameter

El máximo camino más corto entre cualquier par de nodos. En grafos muy grandes indica la posibilidad de que la información se difunda más o menos fácilmente. El algoritmo tiene costo \$O(n\^3)\$. En Twitter hay cientos de millones de usuarios,...

\> \> \`get_diameter\`

\> \> \`diameter\`- el camino más largo entre dos nodos.

\`\`\`{r}

plot(g1)

diameter(g1)

\`\`\`

### Caminos y distancias

\*\*Distancia geodésica\*\*: El menor número de arcos a atravesar para conectar dos nodos.

\`\`\`{r}

sp \<- shortest_paths(g1, from="1", to="10")

sp\$vpath

sp1 \<- shortest_paths(g1, from="1", to="9")

sp1\$vpath

distances(g1)

\`\`\`

Relacionado con distancias:

\> \> \`distance_table, mean_distance\`

\# Clustering

\*Whether your friends are likely to be friends\*.

\*\*Grupos\*\*: Subconjunto de vértices que comparten características en común.

\- Una primera forma es buscar los triángulos en el grafo. \\\*La medida de clustering (transitividad) es la frecuencia relativa de triángulos cerrados.

\$\$C=\\frac{3\*\\mbox{ número de triángulos }}{\\mbox{número de triples conectados}}\$\$

### Transitivity

\*friends of friends to be friends and enemies of enemies to be enemies\*

Probabilidad de que vértices adyacentes de un vértice estén conectados - se denomina también coeficiente de agrupación o \*clustering\*.

\> \> \`transitivity\`, \`shortest_paths\`

#### Global clustering:

\`\`\`{r}

transitivity(g1, type = "global")

\`\`\`

#### Local clustering

Fracción de triples conectados a través de cada vértice que son cerrados.

\`\`\`{r}

transitivity(g1, type = "local")

\`\`\`

\# Otras medidas y definiciones

\- Densidad: Número de conexiones respecto al total de conexiones posibles. Un grafo completo tiene una densidad igual a 1 - \`edge_density\`.

\- Popularidad: nodos que son centrales tienden a ser más populares.

\- Cliques: todos con todos - \`clique_num(g, min=k)\` encuenta cliques con un mínimo de k vértices.

\- Componentes: Una componente es el conjunto de vértices de la que tienen conexiones entre ellos. Una red puede tener varias componentes - \`components\`

\- Nodos a distancia k - \`random_walk\`.

\- Hub, Authorities - \`hub_score, authority.score\` un nodo se denomina hub tiene muchos enlaces de salida y se denomina authorities si tiene muchos de entrada.

\- detección de comunidades: \`cluster_edge_betweenness\`

## Proyecto SNA - USairports

 

Nota: Buscar información en   [https://igraph.org/r/](https://igraph.org/r/) 

Cargamos la librería **igraphdata** y el dataset  **USairports**. 

>> Cambia el nombre al grafo (nuevo nombre US) usando:``graph_attr``.  

  
1. Visualizar el grafo.
2. Usar función ``V`` para acceder a los vértices del grafo. Visualizar los cinco primeros vértices. 
3. Usar función ``E`` para acceder a los arcos del grafo. Visualizar los cinco primeros arcos. 
4. Mira las propiedades asociadas a los vértices ``vertex_attr_names``, ``vertex_attr``. 
5. Usando estas propiedades extrae los nombres de los 5 primeros aeropuertos y de sus ciudades. 
6.Examina las propiedades asociadas a los arcos ``edge_attr_names``,  ``edge_`attr```.
7. Usando estas propiedades extrae los nombres de los 5 primeros compañías aéreas (carrier),  de cuantas salidas tiene cada una de estas compañías.
8. Mira las conexiones entre los cinco primeros aeropuertos.  
9. Usa ``vcount`` para saber el tamaño del grafo.
10. Usa ``V()`` y las funciones de manejo de listas para añadirle un nuevo atributo a los vértices: *Group* que va a tener como valor para cada aeropuerto los valores "A" o "B" aleatoriamente. 
11. Analizar qué hacen las siguientes órdenes:
```{r,eval=FALSE}
#Selector de arcos:  $\%--\%$ para acceder a los arcos entre dos vértices. 
E(USairports)["JFK" %--% "BOS"] 
# Si los arcos son dirigidos
unique(E(USairports)["JFK" %->% "BOS"]$Carrier) 
```
12. Analizar qué hacen las siguientes órdenes:
```{r,eval=FALSE}
#Los selectores se pueden usar entre grupos de  vértices. 
#Todos los vuelos de  California a New York # Buscar patrón (grep -pattern matching), el código de estado de el código de la ciudad 
inCal <- grepl("CA$", V(USairports)$City)
inNy <- grepl("NY$", V(USairports)$City)

# Arcos de   CA a NY
E(USairports)[V(USairports)[inCal] %->% V(USairports)[inNy]]

```

13. Eliminar del grafo el aeropuerto último de la lista de aeropuertos.

14. Eliminar la conexión entre *BJC* y *MIA*.
15. Encontrar las conexiones directas desde *BOS*.

16. Encontrar las conexiones desde *BOS*.

 
17. Caminos y distancias entre dos aeropuertos. Explica cómo calcularlas. ¿Qué aeropuertos están a más de 1000 km?

18. ¿Cuantas conexiones de entrada y salida tiene el primer aeropuerto?

19. ¿Cuales son las ciudades vecinas de *Bangor* (conectadas por vuelos directamente) Usa ``neighbors``.
20. Analizar qué hacen las siguientes órdenes:
```{r,eval=FALSE}
# Extraer todos los vecinos de un vértice particular a una distancia $d$:
# Vértices a distancia 2 de JFK y  LAX
d2Vertices <- ego(USairports, nodes = c("JFK","LAX"), order=2)
# Vecinos de un vértice como un nuevo gráfico 
JFKNet <- make_ego_graph(USairports, nodes = "JFK", order=2) 
```

21. Pasar el grafo a un dataframe. 
22. Pasar el grafo a una matriz  y encontrar los aeropuertos conectados por tres escalas. Guardar en un grafo y visualizarlo.
23. Aplicar a este grafo, las medidas de calidad de grafos: tamaño, diámetro, clustering, transitividad, etc.  Buscar información en   [https://igraph.org/r/](https://igraph.org/r/) 
24. Eliminar ciclos en el grafo. Buscar información de ``simplify``.

## Proyecto -  películas + actores

- En el ejercicio verás funciones aplicadas al grado y sus resultados como resumen, repaso y explicación de nuevas funcionalidades. 
- Aparecen resultados sin el código correspondiente. Esos son los apartados a resolver (los resultados que aquí aparecen son orientativos - no tiene porqué salir exáctamente lo mismo).

```{r}
library(readr) 
library(igraph)
actores <-  read_csv("data/actores.csv")
peliculas <-  read_csv("data/peliculas.csv")
 
```



###  crear grafo

>> Crea un grafo dirigido usando igraph con los dos data.frames leidos anteriormente



>> Visualiza el grafo

```{r,echo=FALSE}
grafo_peliculas <- graph_from_data_frame(d=peliculas, vertices=actores, directed=FALSE)
grafo_peliculas
plot(grafo_peliculas)
```

### Análisis del grafo

>> ¿Nodos en el grafo?

```{r, echo=FALSE}
vcount(grafo_peliculas)
length(V(grafo_peliculas) )

```

>> ¿Arcos en el grafo?

```{r, echo=FALSE}
 
ecount(grafo_peliculas)

```

>> Nodo 3 del grafo

```{r, echo=FALSE}
 
V(grafo_peliculas)[3]

```

>> Arco 1 del grafo

```{r, echo=FALSE}
 
E(grafo_peliculas)[1]

```




Cambia algunas propiedades del grafo:


>> Cambia el layout del grafo (he usado el de estrella pero puedes usar el que quieras.

```{r, echo=FALSE}
forma1 <- layout_(grafo_peliculas, as_star())
plot(grafo_peliculas, layout =forma1)
```

>> Agrupar los nodos de protagonistas que han ganado un oscar

```{r, echo=FALSE}
indices1 <-V(grafo_peliculas)$BestActorActress=="Winner"  

plot(grafo_peliculas, layout =forma1,mark.groups = which(indices1),edge.size = 2)
```



###  Cambiar atributos del grafo

Para acceder a los atributos del grafo usamos:

```{r}
grafo_peliculas
# en attr y edges veis los atributos de vértices y de arcos
vertex_attr(grafo_peliculas)
edge_attr(grafo_peliculas)

V(grafo_peliculas)
V(grafo_peliculas)$name
V(grafo_peliculas)$Gender
V(grafo_peliculas)$Gender
V(grafo_peliculas)$BestActorActress

E(grafo_peliculas)[1]
E(grafo_peliculas)$Movie

V(grafo_peliculas)$color <- "green"

E(grafo_peliculas)$color <- "blue"
 
vertex_attr(grafo_peliculas)
grafo_peliculas[]# la matriz de adyacencia
```


Recordar usar funciones vectoriales: 

```{r}
pelis <- c("Forest Gump", "The Rock")
indices <- E(grafo_peliculas)$Movie %in% pelis

E(grafo_peliculas)[indices]$color <- "red"
plot(grafo_peliculas, layout =forma1)
vertex_attr(grafo_peliculas)
edge_attr(grafo_peliculas)
```


Más información de los grafos, vértices y arcos: color, size, shape, etc.

-   [https://igraph.org/r/doc/](<https://igraph.org/r/doc/>)

-   [[[https://igraph.org/r/doc/plot.common.html](https://igraph.org/r/doc/plot.common.html](https://igraph.org/r/doc/plot.common.html)]([https://igraph.org/r/doc/plot.common.html](https://igraph.org/r/doc/plot.common.html](https://igraph.org/r/doc/plot.common.html)](https://igraph.org/r/doc/plot.common.html))

>> Calcula los índices de los vértices del grafo correspondientes a los protagonistas que han ganado un oscar (no mirando en el dataset). Usando estos índices, destaca en amarillo los actores que han ganado un oscar.

```{r,echo=FALSE}
indices1 <-V(grafo_peliculas)$BestActorActress=="Winner"  

V(grafo_peliculas)[indices1]

V(grafo_peliculas)[indices1]$color = "yellow"
plot(grafo_peliculas, layout =forma1)


```

>> Destaca con un arco rojo qué actores han trabajado juntos en Apollo13 o en The Rock.

```{r,echo=FALSE}
indices <-E(grafo_peliculas)$Movie=="Apollo 13" |  E(grafo_peliculas)$Movie=="The Rock" 

E(grafo_peliculas)[indices]

E(grafo_peliculas)[indices]$color = "red"
plot(grafo_peliculas, layout =forma1)


```

>> Para los ganadores de oscar, hacemos que el tamaño del nodo se corresponda con la importancia de ese actor en el dataset  y además que la etiqueta sea más grande :

Definimos la importancia como el número de películas multiplicado por 15. 

Ayuda: ver funciones ``strength(grafo)``  


```{r,echo=FALSE}
V(grafo_peliculas)$size <- strength(grafo_peliculas)*15


V(grafo_peliculas)$label.cex <- 1.2

V(grafo_peliculas)[indices1]$label.cex <- 2

plot(grafo_peliculas, layout =forma1)

```

>> Eliminar el nombre (la etiqueta - atributo label) de los nodos con protagonistas con importancia menor que  4. 

```{r,echo=FALSE}
indices2 <- which(strength(grafo_peliculas)<4)
V(grafo_peliculas)$label <- V(grafo_peliculas)$name

V(grafo_peliculas)[indices2]$label <- NA
plot(grafo_peliculas, layout =forma1)
```


### Modificar el grafo

Para practicar todo lo visto: 
- Modifica los atributos del grafo para que se muestre parecido al siguiente (función ``legend`` para las leyendas):

```{r,echo=FALSE}
E(grafo_peliculas)$color <- ifelse(E(grafo_peliculas)$Movie == "Forest Gump", "green", 
                         ifelse(E(grafo_peliculas)$Movie == "Apollo 13", "black",
                         ifelse(E(grafo_peliculas)$Movie == "The Rock", "orange", "red")))
V(grafo_peliculas)$color <- ifelse(V(grafo_peliculas)$Gender == "Male", "lightblue", "pink")
indices <-E(grafo_peliculas)$Movie=="Apollo 13" |  E(grafo_peliculas)$Movie=="The Rock" 

E(grafo_peliculas)[indices]

E(grafo_peliculas)[indices]$color = "red"

plot(grafo_peliculas, layout =forma1)
legend("topleft", c("Male","Female"), pch=21,
  col="#777777", pt.bg=c("yellow","orange"), pt.cex=2, cex=.8)
legend("bottomright", c("Forest Gump","Apollo 13", "The Rock", "Titanic"), 
       col=c("blue","black","grey","red"), lty=1, cex=.8)
```

 
