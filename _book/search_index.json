[["index.html", "A Minimal Book Example Chapter 1 About 1.1 Usage 1.2 Render book 1.3 Preview book", " A Minimal Book Example John Doe 2022-05-15 Chapter 1 About This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports; for example, a math equation \\(a^2 + b^2 = c^2\\). 1.1 Usage Each bookdown chapter is an .Rmd file, and each .Rmd file can contain one (and only one) chapter. A chapter must start with a first-level heading: # A good chapter, and can contain one (and only one) first-level heading. Use second-level and higher headings within chapters like: ## A short section or ### An even shorter section. The index.Rmd file is required, and is also your first book chapter. It will be the homepage when you render the book. 1.2 Render book You can render the HTML version of this example book without changing anything: Find the Build pane in the RStudio IDE, and Click on Build Book, then select your output format, or select “All formats” if you’d like to use multiple formats from the same book source files. Or build the book from the R console: bookdown::render_book() To render this example to PDF as a bookdown::pdf_book, you’ll need to install XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. 1.3 Preview book As you work, you may start a local server to live preview this HTML book. This preview will update as you edit the book when you save individual .Rmd files. You can start the server in a work session by using the RStudio add-in “Preview book”, or from the R console: bookdown::serve_book() "],["hello-bookdown.html", "Chapter 2 Hello bookdown", " Chapter 2 Hello bookdown ssss # Visualización de tablas desde Rmarkdown #install.packages(&quot;kableExtra&quot;) library(knitr) library(kableExtra) options(knitr.table.format = &quot;html&quot;) library(igraph) library(igraphdata) library(tidyverse) "],["social-network-analysis.html", "Chapter 3 Social Network Analysis 3.1 R for SNA", " Chapter 3 Social Network Analysis Disciplina con base sólida de Matemática Aplicada: Teoría de Grafos y Matemática Discreta. Unida con Álgebra Lineal: las bases de Pagerank (algoritmo de Google) The Mathematics of Google Search. Describir las relaciones entre los elementos de una red y extraer conocimiento acerca de las estructuras sociales que existen en esa red. Tópico de enorme interés para extraer conocimiento de redes sociales en cualquier área. en una red los actores no intervienen aislados decribir todos los actores intervinientes en las redes redes de alta complejidad Existen muy destacadas aplicaciones para SNA: 3.0.1 Gephi https://gephi.org https://gephi.org/tutorials/gephi-tutorial-quick_start.pdf Exploratory Data Analysis: intuition-oriented analysis by networks manipulations in real time. Link Analysis: revealing the underlying structures of associations between objects. Social Network Analysis: easy creation of social data connectors to map community organizations and small-world networks. Biological Network analysis: representing patterns of biological data. 3.0.2 Cytoscape https://cytoscape.org Cytoscape is an open source software platform for visualizing molecular interaction networks and biological pathways and integrating these networks with annotations, gene expression profiles and other state data. Library for visualization 3.1 R for SNA Usaremos el paquete igraph. Nos servirá para analizar más adelante datos extraído de Twiter. Ventajas de usar R: Reproducible research no es posible con las aplicaciones GUI. Herramientas sólidas para manipular los datos. Cada vez más paquetes diseñados para hacer de R una herramienta completa de análisis de redes. Paquetes statnet y igraph. Thomas Lin Pedersen ha publicado los paquetes tidygraph y ggraph, que aprovechan la potencia de igraph de forma coherente con el flujo de trabajo de tidyverse. Crear gráficos de red interactivos con el marco htmlwidgets que traduce el código de R a JavaScript. "],["elementos-de-una-red.html", "Chapter 4 Elementos de una red 4.1 Representación de redes", " Chapter 4 Elementos de una red nodos o vértices de grafo (nodes, vertices) ## [1] &quot;Tom Hanks&quot; &quot;Gary Sinise&quot; &quot;Bill Paxton&quot; &quot;Kevin Bacon&quot; &quot;Ed Harris&quot; ## [6] &quot;Sean Connery&quot; &quot;Robin Wright&quot; &quot;Nicolas Cage&quot; arcos o enlaces (edges, links) ## [,1] [,2] ## [1,] &quot;Tom Hanks&quot; &quot;Gary Sinise&quot; ## [2,] &quot;Tom Hanks&quot; &quot;Robin Wright&quot; ## [3,] &quot;Gary Sinise&quot; &quot;Robin Wright&quot; ## [4,] &quot;Tom Hanks&quot; &quot;Gary Sinise&quot; ## [5,] &quot;Tom Hanks&quot; &quot;Bill Paxton&quot; ## [6,] &quot;Tom Hanks&quot; &quot;Kevin Bacon&quot; ## [7,] &quot;Tom Hanks&quot; &quot;Ed Harris&quot; ## [8,] &quot;Gary Sinise&quot; &quot;Bill Paxton&quot; ## [9,] &quot;Gary Sinise&quot; &quot;Kevin Bacon&quot; ## [10,] &quot;Gary Sinise&quot; &quot;Ed Harris&quot; ## [11,] &quot;Bill Paxton&quot; &quot;Kevin Bacon&quot; ## [12,] &quot;Bill Paxton&quot; &quot;Ed Harris&quot; ## [13,] &quot;Kevin Bacon&quot; &quot;Ed Harris&quot; ## [14,] &quot;Ed Harris&quot; &quot;Sean Connery&quot; ## [15,] &quot;Ed Harris&quot; &quot;Nicolas Cage&quot; ## [16,] &quot;Sean Connery&quot; &quot;Nicolas Cage&quot; Nodos y arcos pueden contender atributos adicionales con importante información: ## [1] &quot;Forest Gump&quot; &quot;Forest Gump&quot; &quot;Forest Gump&quot; &quot;Apollo 13&quot; &quot;Apollo 13&quot; ## [6] &quot;Apollo 13&quot; &quot;Apollo 13&quot; &quot;Apollo 13&quot; &quot;Apollo 13&quot; &quot;Apollo 13&quot; ## [11] &quot;Apollo 13&quot; &quot;Apollo 13&quot; &quot;Apollo 13&quot; &quot;The Rock&quot; &quot;The Rock&quot; ## [16] &quot;The Rock&quot; 4.1 Representación de redes 4.1.1 Grafos como listas de arcos data.frame o matriz (si los datos del mismo tipo) que contiene dos columnas: primera columna: nodos que son el origen de una conexión segunda columna: nodos que son el destino de la conexión Si el sentido es importante, la red se denomina dirigida, en otro caso, no dirigida. alumnos1 &lt;- c(&quot;Luis&quot;, &quot;Ana&quot;, &quot;Fran&quot;, &quot;Pedro&quot;, &quot;Laura&quot;, &quot;Susana&quot;) alumnos2 &lt;- c(&quot;Juan&quot;, &quot;Jose&quot;, &quot;Amalia&quot;, &quot;Lucía&quot;, &quot;Maite&quot;, &quot;Eduardo&quot;) grupos &lt;- data.frame(integrante1 = alumnos1, integrante2 = alumnos2, stringsAsFactors = F) print(grupos) ## integrante1 integrante2 ## 1 Luis Juan ## 2 Ana Jose ## 3 Fran Amalia ## 4 Pedro Lucía ## 5 Laura Maite ## 6 Susana Eduardo str(grupos) ## &#39;data.frame&#39;: 6 obs. of 2 variables: ## $ integrante1: chr &quot;Luis&quot; &quot;Ana&quot; &quot;Fran&quot; &quot;Pedro&quot; ... ## $ integrante2: chr &quot;Juan&quot; &quot;Jose&quot; &quot;Amalia&quot; &quot;Lucía&quot; ... 4.1.2 Grafos como matrices # Se pueden usar matrices &#39;sparse&#39; A &lt;- rbind(c(0,1,0), c(1,0,1), c(1,0,0)) nodeNames &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) dimnames(A) &lt;- list(nodeNames, nodeNames) A ## A B C ## A 0 1 0 ## B 1 0 1 ## C 1 0 0 str(A) ## num [1:3, 1:3] 0 1 1 1 0 0 0 1 0 ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ..$ : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; Caminos de longitud dos, tres, etc: # Multiplicación matricial A2 &lt;- A %*% A A2 ## A B C ## A 1 0 1 ## B 1 1 0 ## C 0 1 0 A3 &lt;- A %*% A %*% A A3 ## A B C ## A 1 1 0 ## B 1 1 1 ## C 1 0 1 Representado arcos: Arcos &lt;- rbind(c(&quot;A&quot;,&quot;B&quot;), c(&quot;B&quot;,&quot;A&quot;), c(&quot;B&quot;,&quot;C&quot;), c(&quot;C&quot;,&quot;A&quot;)) Arcos ## [,1] [,2] ## [1,] &quot;A&quot; &quot;B&quot; ## [2,] &quot;B&quot; &quot;A&quot; ## [3,] &quot;B&quot; &quot;C&quot; ## [4,] &quot;C&quot; &quot;A&quot; "],["introducción-a-igraph.html", "Chapter 5 Introducción a igraph 5.1 Acceder a elementos de grado 5.2 Construir/Modificar un grafo", " Chapter 5 Introducción a igraph # Instalar la primera vez - descomentar #install.packages(&quot;igraph&quot;) #install.packages(&quot;igraphdata&quot;) library(igraph) library(igraphdata) # Importar la red de datasets ya establecidos: igraphdata # Limpia la memoria - Cuidado - borra todas las variables rm(list=ls()) #Lista de datasets de redes de nodos en igraph # data(package=&quot;igraphdata&quot;) # El paquete tiene un conjunto de datasets # Carga data set y vemos que contiene #Red social entre miembros de club de karate de universidad data(karate,package=&quot;igraphdata&quot;) plot(karate) 5.1 Acceder a elementos de grado # UKfaculty: Friendship network of a UK university faculty data(UKfaculty) plot(UKfaculty) UKfaculty ## IGRAPH 6f42903 D-W- 81 817 -- ## + attr: Type (g/c), Date (g/c), Citation (g/c), Author (g/c), Group ## | (v/n), weight (e/n) ## + edges from 6f42903: ## [1] 57-&gt;52 76-&gt;42 12-&gt;69 43-&gt;34 28-&gt;47 58-&gt;51 7-&gt;29 40-&gt;71 5-&gt;37 48-&gt;55 ## [11] 6-&gt;58 21-&gt; 8 28-&gt;69 43-&gt;21 67-&gt;58 65-&gt;42 5-&gt;67 52-&gt;75 37-&gt;64 4-&gt;36 ## [21] 12-&gt;49 19-&gt;46 37-&gt; 9 74-&gt;36 62-&gt; 1 15-&gt; 2 72-&gt;49 46-&gt;62 2-&gt;29 40-&gt;12 ## [31] 22-&gt;29 71-&gt;69 4-&gt; 3 37-&gt;69 5-&gt; 6 77-&gt;13 23-&gt;49 52-&gt;35 20-&gt;14 62-&gt;70 ## [41] 34-&gt;35 76-&gt;72 7-&gt;42 37-&gt;42 51-&gt;80 38-&gt;45 62-&gt;64 36-&gt;53 62-&gt;77 17-&gt;61 ## [51] 7-&gt;68 46-&gt;29 44-&gt;53 18-&gt;58 12-&gt;16 72-&gt;42 52-&gt;32 58-&gt;21 38-&gt;17 15-&gt;51 ## [61] 22-&gt; 7 22-&gt;69 5-&gt;13 29-&gt; 2 77-&gt;12 37-&gt;35 18-&gt;46 10-&gt;71 22-&gt;47 20-&gt;19 ## + ... omitted several edges V(UKfaculty) ## + 81/81 vertices, from 6f42903: ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 ## [76] 76 77 78 79 80 81 E(UKfaculty) ## + 817/817 edges from 6f42903: ## [1] 57-&gt;52 76-&gt;42 12-&gt;69 43-&gt;34 28-&gt;47 58-&gt;51 7-&gt;29 40-&gt;71 5-&gt;37 48-&gt;55 ## [11] 6-&gt;58 21-&gt; 8 28-&gt;69 43-&gt;21 67-&gt;58 65-&gt;42 5-&gt;67 52-&gt;75 37-&gt;64 4-&gt;36 ## [21] 12-&gt;49 19-&gt;46 37-&gt; 9 74-&gt;36 62-&gt; 1 15-&gt; 2 72-&gt;49 46-&gt;62 2-&gt;29 40-&gt;12 ## [31] 22-&gt;29 71-&gt;69 4-&gt; 3 37-&gt;69 5-&gt; 6 77-&gt;13 23-&gt;49 52-&gt;35 20-&gt;14 62-&gt;70 ## [41] 34-&gt;35 76-&gt;72 7-&gt;42 37-&gt;42 51-&gt;80 38-&gt;45 62-&gt;64 36-&gt;53 62-&gt;77 17-&gt;61 ## [51] 7-&gt;68 46-&gt;29 44-&gt;53 18-&gt;58 12-&gt;16 72-&gt;42 52-&gt;32 58-&gt;21 38-&gt;17 15-&gt;51 ## [61] 22-&gt; 7 22-&gt;69 5-&gt;13 29-&gt; 2 77-&gt;12 37-&gt;35 18-&gt;46 10-&gt;71 22-&gt;47 20-&gt;19 ## [71] 19-&gt;31 68-&gt;13 49-&gt;69 30-&gt;63 5-&gt;49 53-&gt;75 62-&gt;57 73-&gt;81 29-&gt;69 71-&gt;40 ## [81] 19-&gt;58 49-&gt;42 37-&gt; 5 18-&gt; 2 20-&gt;80 75-&gt;53 15-&gt;54 76-&gt;58 40-&gt;23 5-&gt;12 ## [91] 20-&gt;54 6-&gt;47 51-&gt;14 78-&gt; 4 52-&gt;49 29-&gt;55 27-&gt;35 66-&gt; 6 21-&gt;29 4-&gt;61 ## + ... omitted several edges V(UKfaculty) ## + 81/81 vertices, from 6f42903: ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 ## [76] 76 77 78 79 80 81 str(UKfaculty) ## Class &#39;igraph&#39; hidden list of 10 ## $ : num 81 ## $ : logi TRUE ## $ : num [1:817] 56 75 11 42 27 57 6 39 4 47 ... ## $ : num [1:817] 51 41 68 33 46 50 28 70 36 54 ... ## $ : num [1:817] 580 411 719 376 569 215 533 620 527 592 ... ## $ : num [1:817] 241 433 238 352 258 274 115 24 263 25 ... ## $ : num [1:82] 0 6 23 27 37 65 74 91 93 101 ... ## $ : num [1:82] 0 9 28 32 40 50 58 76 82 87 ... ## $ :List of 4 ## ..$ : num [1:3] 1 0 1 ## ..$ :List of 4 ## .. ..$ Type : chr &quot;TSPE&quot; ## .. ..$ Date : chr &quot;Mon Mar 19 21:56:02 2007&quot; ## .. ..$ Citation: chr &quot;Nepusz T., Petroczi A., Negyessy L., Bazso F.: Fuzzy communities and the concept of bridgeness in complex netwo&quot;| __truncated__ ## .. ..$ Author : chr &quot;Nepusz T., Petroczi A., Negyessy L., Bazso F.&quot; ## ..$ :List of 1 ## .. ..$ Group: num [1:81] 3 1 3 3 2 2 2 1 3 2 ... ## ..$ :List of 1 ## .. ..$ weight: num [1:817] 4 14 4 4 10 2 6 2 4 4 ... ## $ :&lt;environment: 0x7fb37e593200&gt; head(E(UKfaculty)$weight) ## [1] 4 14 4 4 10 2 head(V(UKfaculty)$Group) ## [1] 3 1 3 3 2 2 5.2 Construir/Modificar un grafo Añadir arcos a un grafo vacío: # Un grafo dirigido vacío g &lt;- make_empty_graph(n = 0, directed = TRUE) g ## IGRAPH 5966fe3 D--- 0 0 -- ## + edges from 5966fe3: g &lt;- g + vertices(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) g ## IGRAPH 6967d84 DN-- 3 0 -- ## + attr: name (v/c) ## + edges from 6967d84 (vertex names): # Arcos: A to C , B to C g &lt;- g + edges(c(&quot;A&quot;,&quot;C&quot;, &quot;B&quot;,&quot;C&quot;)) g ## IGRAPH 51fbb7c DN-- 3 2 -- ## + attr: name (v/c) ## + edges from 51fbb7c (vertex names): ## [1] A-&gt;C B-&gt;C # Eliminar arco A g &lt;- g - V(g)[&quot;A&quot;] g ## IGRAPH fb534af DN-- 2 1 -- ## + attr: name (v/c) ## + edge from fb534af (vertex names): ## [1] B-&gt;C # Eliminará todos los arcos conectados con A Lista de arcos: graph() and get.edgelist(): # Un grafo dirigido vacío # graph() id desde 1. g1 &lt;- graph( c(1,2, 1,3, 2,3, 3,4 ));g1 ## IGRAPH 2017861 D--- 4 4 -- ## + edges from 2017861: ## [1] 1-&gt;2 1-&gt;3 2-&gt;3 3-&gt;4 summary(g1) ## IGRAPH 2017861 D--- 4 4 -- plot(g1) # El parámetro &quot;directed&quot; a FALSE para # grafos no dirigidos. g2 &lt;- graph( c(1,2, 1,3, 2,3, 3,4 , 3, 5, 1, 3), directed=FALSE); g2 ## IGRAPH f817106 U--- 5 6 -- ## + edges from f817106: ## [1] 1--2 1--3 2--3 3--4 3--5 1--3 summary(g2) ## IGRAPH f817106 U--- 5 6 -- plot(g2) #Obtener la lista de arcos a partir de un grafo edgelist&lt;-get.edgelist(g2) ; edgelist ## [,1] [,2] ## [1,] 1 2 ## [2,] 1 3 ## [3,] 2 3 ## [4,] 3 4 ## [5,] 3 5 ## [6,] 1 3 edgelist &lt;- as_edgelist(g2) ; edgelist ## [,1] [,2] ## [1,] 1 2 ## [2,] 1 3 ## [3,] 2 3 ## [4,] 3 4 ## [5,] 3 5 ## [6,] 1 3 # Obtener el grafo a partir de la lista de arcos g3&lt;-graph( t(edgelist)); g3; plot(g3) ## IGRAPH 4b29320 D--- 5 6 -- ## + edges from 4b29320: ## [1] 1-&gt;2 1-&gt;3 2-&gt;3 3-&gt;4 3-&gt;5 1-&gt;3 g3&lt;-graph( edgelist); g3; plot(g3) ## IGRAPH 9fa17c6 D--- 5 6 -- ## + edges from 9fa17c6: ## [1] 1-&gt;1 2-&gt;3 3-&gt;1 2-&gt;3 3-&gt;4 5-&gt;3 # algunos parámetros de plot plot(g3, vertex.color=&quot;green&quot;, edge.arrow.size=0.5, vertex.size=25, edge.curved=0.5, layout_as_star=TRUE) Matrices de adyacencia: graph.adjacency(), get.adjacency() adjm_u&lt;-matrix( c(0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0), nrow=6, ncol=6, byrow = TRUE) #grafo a partir de matriz de adyacencia g_adj_u &lt;- graph.adjacency(adjm_u, mode=&quot;undirected&quot;) plot(g_adj_u) # Matriz de adyacencia a partir de grafo A &lt;- get.adjacency(g_adj_u); A ## 6 x 6 sparse Matrix of class &quot;dgCMatrix&quot; ## ## [1,] . 1 . . 1 . ## [2,] 1 . 1 . 1 . ## [3,] . 1 . 1 . . ## [4,] . . 1 . 1 1 ## [5,] 1 1 . 1 . . ## [6,] . . . 1 . . A &lt;- as_adjacency_matrix(g_adj_u, sparse = FALSE) A ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 0 1 0 0 1 0 ## [2,] 1 0 1 0 1 0 ## [3,] 0 1 0 1 0 0 ## [4,] 0 0 1 0 1 1 ## [5,] 1 1 0 1 0 0 ## [6,] 0 0 0 1 0 0 Grafo a partir de data frame # Primero, crear el data frame node1 = c(&quot;Ella&quot;, &quot;Tu&quot;, &quot;El&quot;); node2 = c(&quot;El&quot;, &quot;Ella&quot;, &quot;Tu&quot;) weight = c(10, -2, 3) df = data.frame(node1, node2, weight); df ## node1 node2 weight ## 1 Ella El 10 ## 2 Tu Ella -2 ## 3 El Tu 3 # Crear el grafo g &lt;- graph.data.frame(df, directed=FALSE); g ## IGRAPH c44cb8b UNW- 3 3 -- ## + attr: name (v/c), weight (e/n) ## + edges from c44cb8b (vertex names): ## [1] Ella--El Ella--Tu Tu --El plot(g) # Si se conocen los vértices # g &lt;- graph.data.frame(df, vertices=listvertices, directed=FALSE);g # Obtener los nombres de los nodos V(g)$name ## [1] &quot;Ella&quot; &quot;Tu&quot; &quot;El&quot; # Obtener los pesos de los arcos E(g)$weight ## [1] 10 -2 3 Grafo a partir de literales #?graph_from_literal g &lt;- graph_from_literal(A--C, A-+D, C-+A, , D-+C) g ## IGRAPH 13eae4c DN-- 4 3 -- ## + attr: name (v/c) ## + edges from 13eae4c (vertex names): ## [1] A-&gt;D C-&gt;A D-&gt;C plot(g) #IGRAPH DN-- 4 4 -- #+ attr: name (v/c) #+ edges (vertex names): #[1] A-&gt;D D-&gt;C D-&gt;B B-&gt;A G3 &lt;-graph_from_literal(A-B, B -+C) plot(G3) G3 &lt;-graph_from_literal(A-B, B -C) plot(G3) grafo aleatorio g_random &lt;- sample_gnp(10, 0.2, directed = FALSE, loops = FALSE) plot(g_random) "],["visualización.html", "Chapter 6 Visualización 6.1 Layout 6.2 Dibujar grafos ponderados 6.3 Cambiar aspecto y propiedades de un grafo 6.4 Ejemplos - plantillas", " Chapter 6 Visualización Buscar ayuda de los comandos plot.igraph, igraph.plotting. A continuación dibujamos algunos grafos interesantes: #library(igraph) # Trees g &lt;- make_tree(27, children=3) g; plot(g) ## IGRAPH f389ce1 D--- 27 26 -- Tree ## + attr: name (g/c), children (g/n), mode (g/c) ## + edges from f389ce1: ## [1] 1-&gt; 2 1-&gt; 3 1-&gt; 4 2-&gt; 5 2-&gt; 6 2-&gt; 7 3-&gt; 8 3-&gt; 9 3-&gt;10 4-&gt;11 4-&gt;12 4-&gt;13 ## [13] 5-&gt;14 5-&gt;15 5-&gt;16 6-&gt;17 6-&gt;18 6-&gt;19 7-&gt;20 7-&gt;21 7-&gt;22 8-&gt;23 8-&gt;24 8-&gt;25 ## [25] 9-&gt;26 9-&gt;27 # Cliques g &lt;- make_full_graph(n=6) g; plot(g) ## IGRAPH 5d37b57 U--- 6 15 -- Full graph ## + attr: name (g/c), loops (g/l) ## + edges from 5d37b57: ## [1] 1--2 1--3 1--4 1--5 1--6 2--3 2--4 2--5 2--6 3--4 3--5 3--6 4--5 4--6 5--6 # Lattices g &lt;- make_lattice(dimvector = c(5,5), circular = FALSE) V(g)$label &lt;- NA g; plot(g) ## IGRAPH 5d0e548 U--- 25 40 -- Lattice graph ## + attr: name (g/c), dimvector (g/n), nei (g/n), mutual (g/l), circular ## | (g/l), label (v/l) ## + edges from 5d0e548: ## [1] 1-- 2 1-- 6 2-- 3 2-- 7 3-- 4 3-- 8 4-- 5 4-- 9 5--10 6-- 7 ## [11] 6--11 7-- 8 7--12 8-- 9 8--13 9--10 9--14 10--15 11--12 11--16 ## [21] 12--13 12--17 13--14 13--18 14--15 14--19 15--20 16--17 16--21 17--18 ## [31] 17--22 18--19 18--23 19--20 19--24 20--25 21--22 22--23 23--24 24--25 #Stars g &lt;- make_star(n=10,mode = &quot;undirected&quot;) g; plot(g) ## IGRAPH a6d07e6 U--- 10 9 -- Star ## + attr: name (g/c), mode (g/c), center (g/n) ## + edges from a6d07e6: ## [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--10 Anillo con conexiones cruzadas: g &lt;- make_ring(10, directed=TRUE, mutual=TRUE) V(g)$name &lt;- LETTERS[1:10] g &lt;- g + edges(9,5, 7,1, 1,5) plot(g) 6.1 Layout Un layout es un conjunto de coordenadas x,y preestablecidas. Se pueden especificar manualmente o usando layout_functions Determina la posición de los nodos en la red. Hay layouts ya diseñados o puedes diseñarlo desde 0. Intentar minimizar cruces de arcos. Algoritmos que lo consiguen: por ejemplo - Kamada Kawai algorithm, the Fruchterman Reingold algorithm, etc. Lykamada &lt;- layout.kamada.kawai(g) plot(g, layout=Lykamada) Lyfruchtermant &lt;- layout.fruchterman.reingold(g) plot(g, layout=Lyfruchtermant) lo &lt;- layout_in_circle(g) head(lo, n=4) ## [,1] [,2] ## [1,] 1.000000 0.0000000 ## [2,] 0.809017 0.5877853 ## [3,] 0.309017 0.9510565 ## [4,] -0.309017 0.9510565 # lo es una matriz de coordenadas lo ## [,1] [,2] ## [1,] 1.000000 0.000000e+00 ## [2,] 0.809017 5.877853e-01 ## [3,] 0.309017 9.510565e-01 ## [4,] -0.309017 9.510565e-01 ## [5,] -0.809017 5.877853e-01 ## [6,] -1.000000 1.224647e-16 ## [7,] -0.809017 -5.877853e-01 ## [8,] -0.309017 -9.510565e-01 ## [9,] 0.309017 -9.510565e-01 ## [10,] 0.809017 -5.877853e-01 plot(g, layout=lo) # See ?layout_ for a full list # Para redes tipo árbol: layout_as_tree gTree &lt;- make_tree(15) plot(gTree, layout=layout_as_tree(gTree, root = 1)) # layout como un grid plot(g, layout=layout_on_grid(g)) Mallas: library(igraph) #Buscar en ayuda #?igraph::layout g &lt;- make_tree(15) set.seed(3952) layout1 &lt;- layout.fruchterman.reingold(g) plot(g, layout=layout1) # Otra malla diferente plot(g, layout=layout.kamada.kawai) # Malla interactiva - Ejecutar en consola # tkplot(g, layout=layout.kamada.kawai) 6.2 Dibujar grafos ponderados V(g)$label.cex &lt;- ... V(g)$label.color &lt;- ... V(g)$frame.color &lt;- ... E(g)$color &lt;- rgb(.... E(g)$width &lt;- 6.3 Cambiar aspecto y propiedades de un grafo V(g)$shape V(g)$size V(g)$color vertex.shape vertex.color vertex.size set_edge_attr set_vertex_attr set_graph_attr plot(g, vertex.size = 20) plot(g, vertex.size = 10, vertex.color = &quot;blue&quot;, vertex.frame.color = NA, vertex.label = NA) plot(g, vertex.size = 10, vertex.color = &quot;blue&quot;, vertex.frame.color = NA, vertex.label.cex = .7, vertex.label = NA, edge.curved = .5, edge.arrow.size = .3, edge.width = .7) Note: colores en R [http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) library(tidyverse) g1random &lt;- sample_gnp(10, p=0.4) V(g1random)[1]$color &lt;- &quot;yellow&quot; g1random %&gt;% set_edge_attr(&quot;color&quot;,value = &quot;blue&quot;) %&gt;% plot() 6.4 Ejemplos - plantillas Plot vocales como rectángulos g &lt;- make_ring(10, directed=TRUE, mutual=TRUE) V(g)$name &lt;- LETTERS[1:10] g &lt;- g + edges(9,5, 7,1, 1,5) plot(g) vowel &lt;- V(g)$name %in% c(&quot;A&quot;,&quot;E&quot;,&quot;I&quot;,&quot;O&quot;,&quot;U&quot;) + 1 # gives 1 or 2 plot(g, layout=lo, vertex.shape=c(&quot;circle&quot;, &quot;square&quot;)[vowel]) #colores plot(g, layout=lo, vertex.color=c(&quot;tomato2&quot;, &quot;royalblue&quot;)[vowel]) #tamaño plot(g, layout=lo, vertex.size=c(15,30)[vowel]) #Propiedades usando atributos V(g)$shape &lt;- &quot;circle&quot; # Aplicado a todos los vértices V(g)$size &lt;- 15 V(g)$color &lt;- &quot;orange&quot; isVowel &lt;- V(g)$name %in% c(&quot;A&quot;,&quot;E&quot;,&quot;I&quot;,&quot;O&quot;,&quot;U&quot;) # Sobreescribir los nodos vocales V(g)[isVowel]$shape &lt;- &quot;square&quot; V(g)[isVowel]$color &lt;- &quot;royalblue&quot; V(g)[isVowel]$size &lt;- 25 plot(g, layout=lo) Propiedades de los arcos E(g)$width &lt;- 1 v1 &lt;-V(g)[isVowel] v1 ## + 3/10 vertices, named, from 7aec58d: ## [1] A E I E(g)[v1 %--% v1]$width &lt;- 4 # Ver http://igraph.org/r/doc/igraph-es-indexing.html plot(g, layout=lo) #Arcos curvados plot(g, layout=lo, edge.curved=0.3*which_mutual(g)) Agrupaciones por índices: groupList &lt;- list(vowelGroup = which(isVowel), constGroup1 = c(2,3,4), constGroup2 = c(6,7,8)) groupColours &lt;- c(rgb(0,0.3,1,0.5), rgb(0.8,0.4,0.1,0.5), rgb(0.8,0.4,0.1,0.5)) plot(g, layout=layout_with_fr, # Fruchterman?Reingold layout mark.groups=groupList, # Mark the groups mark.col= groupColours, # Eliminar el borde mark.border = NA, edge.curved=0.1*which_mutual(g)) text(0.45,0.1,&quot;Vocales&quot;, cex=1.5) text(0.5,0.9,&quot;Grupo consonantes 1&quot;, cex=1.5) text(-0.8,-1,&quot;Grupo consonantes 2&quot;, cex=1.5) "],["de-twitter.html", "Chapter 7 De Twitter", " Chapter 7 De Twitter El primer paso será extraer los términos usando las técnicas de text mining y crear una matriz de términos (DTM - Document Term Matrix:). Los documentos serían los tweets y los términos serían las palabras o grupos de palabras destacadas en los datos extraidos. Objetivo: Construir una red de términos (personas) basada en sus co-ocurrencias en los mismos tweets (pertenencia a los mismos grupos). "],["exportar-grafos.html", "Chapter 8 Exportar grafos", " Chapter 8 Exportar grafos igraph permite importar y exportar de/desde un considerable número de formatos. Se usan los comandos read_graph y write_graph. Un formato abierto (open) es graphml. write_graph(g, &quot;gr1.graphml&quot;, format=&quot;graphml&quot;) Otros formatos: edgelist: Fichero de texto con arcos en cada línea. pajek: Pajek es un programa popular en Windows para análisis de redes. gml: Graph Modelling Language es uno de los formatos abiertos más populares. graphml: Graph Markup Language es un formato abierto basado en XML. dot: Formato usado por GraphViz. ** Gephi: Para exportar al formato nativo GEXF de Gephise usa el paquete rgexf al que puede convertirse desde un objeto igraph ** Referencias: https://www.r-project.org/nosvn/conferences/useR-2010/slides/Zhang.pdf https://programminghistorian.org/en/lessons/temporal-network-analysis-with-r "],["analysis-of-the-networks-to-extract-knowledge..html", "Chapter 9 Analysis of the Networks to extract knowledge.", " Chapter 9 Analysis of the Networks to extract knowledge. Goal of a SNA proyect http://snap.stanford.edu/class/cs224w-2015/slides/06-applicationsI.pdf Locate people in the network for… higher compensation positive performance evaluations more promotions more good ideas Ego network is a special type of network consisting of one central node and all other nodes directly connected to it. The central node is known as ego, while the other surrounding nodes directly connected to it are known as alters. https://medium.com/applied-data-science/the-google-vs-trick-618c8fd5359f http://olizardo.bol.ucla.edu/classes/soc-111/lessons-winter-2022/5-lesson-egonet-metrics.html Vamos a usar este grafo como ejemplo de las medidas de bondad del grafo. library(igraph) g1 &lt;- graph( c(1,2, 1,3, 2,3, 3,4, 3,5, 1,5, 4,2, 3,6, 4,8, 8,1, 9,1, 10,2, 7,6, 5,10)) g1 ## IGRAPH 6050a01 D--- 10 14 -- ## + edges from 6050a01: ## [1] 1-&gt; 2 1-&gt; 3 2-&gt; 3 3-&gt; 4 3-&gt; 5 1-&gt; 5 4-&gt; 2 3-&gt; 6 4-&gt; 8 8-&gt; 1 ## [11] 9-&gt; 1 10-&gt; 2 7-&gt; 6 5-&gt;10 summary(g1) ## IGRAPH 6050a01 D--- 10 14 -- plot(g1) Vértices, arcos. class(g1) ## [1] &quot;igraph&quot; V(g1) ## + 10/10 vertices, from 6050a01: ## [1] 1 2 3 4 5 6 7 8 9 10 V(g1)[1] ## + 1/10 vertex, from 6050a01: ## [1] 1 E(g1) ## + 14/14 edges from 6050a01: ## [1] 1-&gt; 2 1-&gt; 3 2-&gt; 3 3-&gt; 4 3-&gt; 5 1-&gt; 5 4-&gt; 2 3-&gt; 6 4-&gt; 8 8-&gt; 1 ## [11] 9-&gt; 1 10-&gt; 2 7-&gt; 6 5-&gt;10 E(g1)[1] ## + 1/14 edge from 6050a01: ## [1] 1-&gt;2 class(V(g1)) ## [1] &quot;igraph.vs&quot; class(E(g1)) ## [1] &quot;igraph.es&quot; "],["centrality.html", "Chapter 10 Centrality 10.1 Degree 10.2 Betweenness 10.3 Edge_betweenness 10.4 Closeness 10.5 Eigenvector 10.6 Pagerank", " Chapter 10 Centrality Importancia de los nodos en un grafo. Número de arcos de entrada-salida de los nodos. Redes con alta centralidad tienen pocos nodos con muchas conexiones. Redes con baja centralidad tienen muchos nodos con similar o menos conexiones. Ver https://en.wikipedia.org/wiki/Centrality#PageRank_centrality 10.1 Degree Número de arcos conectados a un vértice. Señala la importancia de un vértice o el nivel de actividad del vértice en la red. Cómo de central es un nodo en la red Cuántos arcos de entrada-salida tiene o con cuántos nodos se conecta directamente via un arco. centr_degree, igraph::degree g1 ## IGRAPH 6050a01 D--- 10 14 -- ## + edges from 6050a01: ## [1] 1-&gt; 2 1-&gt; 3 2-&gt; 3 3-&gt; 4 3-&gt; 5 1-&gt; 5 4-&gt; 2 3-&gt; 6 4-&gt; 8 8-&gt; 1 ## [11] 9-&gt; 1 10-&gt; 2 7-&gt; 6 5-&gt;10 plot(g1) igraph::degree(g1) ## [1] 5 4 5 3 3 2 1 2 1 2 igraph::degree(g1, mode=&quot;in&quot;) ## [1] 2 3 2 1 2 2 0 1 0 1 igraph::degree(g1, mode=&quot;out&quot;) ## [1] 3 1 3 2 1 0 1 1 1 1 deg &lt;- centr_degree(g1) deg ## $res ## [1] 5 4 5 3 3 2 1 2 1 2 ## ## $centralization ## [1] 0.1358025 ## ## $theoretical_max ## [1] 162 10.2 Betweenness Mide el grado en el que la información fluye a través de un vértice particular y su importancia relativa como un intermediario en la red. Describe nodos que son conexiones clave o puentes entre grupos de nodos. El número de caminos más cortos que pasan por un nodo dado (medida relativa) - la suma de las longitudes de los caminos más cortos entre otros nodos pasando por el nodo, dividida por las longitudes de camino más cortas (no necesariamente a través del nodo) entre los otros nodos. igraph::betweenness igraph::betweenness(g1) ## [1] 14 14 25 11 6 0 0 6 0 6 Por el vértice 6 no pasa ningún camino más corto entre dos vértices. Por el vértice 3 pasan 25 caminos más cortos entre dos vértices. … 10.3 Edge_betweenness Similar al anterior pero teniendo en cuenta cada arco. igraph::edge_betweenness g1 &lt;- set.edge.attribute(g1, &quot;weight&quot;, value= 1) bg &lt;- edge_betweenness(g1) plot(g1, edge.label = bg) 10.4 Closeness Distancia a otros nodos. Un nodo con valor alto de este estimador es más central y puede difundir la información a muchos otros nodos. Se obtiene como 1 divido por la suma de las distancias geodésicas desde un vértice al resto. Alcanzará su valor máximo cuando un vértice esté conectado a todos los demás. Longitud media de los caminos más cortos (geodésicos). Mide cuantos pasos se requieren desde un vértice para alcanzar el resto de vértices de la red. Caminos cortos entre vértices señalan que estos están cercanos unos a otros. centr_clo, igraph::closeness igraph::closeness(g1) ## [1] 0.08333333 0.05882353 0.08333333 0.06250000 0.04000000 NaN ## [7] 1.00000000 0.06250000 0.05000000 0.04761905 10.5 Eigenvector No todas las conexiones tienen la misma importancia - medida de la importancia de un nodo. La medida Eigenvector Centrality se calcula como el autovalor de mayor módulo de la matriz de adyacencia que contiene los pesos. a high score to vertices that either have a lot of connections, or are connected to someone with a lot of connections Eigenvector Centrality: eigen_centrality eigen_centrality(g1) ## $vector ## [1] 0.94446858 0.87756472 1.00000000 0.67054129 0.68544140 0.31214483 ## [7] 0.08943566 0.46273222 0.27060890 0.44783212 ## ## $value ## [1] 3.490161 ## ## $options ## $options$bmat ## [1] &quot;I&quot; ## ## $options$n ## [1] 10 ## ## $options$which ## [1] &quot;LA&quot; ## ## $options$nev ## [1] 1 ## ## $options$tol ## [1] 0 ## ## $options$ncv ## [1] 0 ## ## $options$ldv ## [1] 0 ## ## $options$ishift ## [1] 1 ## ## $options$maxiter ## [1] 1000 ## ## $options$nb ## [1] 1 ## ## $options$mode ## [1] 1 ## ## $options$start ## [1] 1 ## ## $options$sigma ## [1] 0 ## ## $options$sigmai ## [1] 0 ## ## $options$info ## [1] 0 ## ## $options$iter ## [1] 6 ## ## $options$nconv ## [1] 1 ## ## $options$numop ## [1] 20 ## ## $options$numopb ## [1] 0 ## ## $options$numreo ## [1] 15 10.6 Pagerank Algoritmo de Google para realizar un ranking con la importancia de los resultados de la búsqueda. Nodos son más importantes si tienen muchos enlaces de entrada. page.rank page.rank(g1) ## $vector ## [1] 0.09371203 0.18396681 0.20662720 0.08224805 0.10879979 0.10239617 ## [7] 0.02370367 0.05865910 0.02370367 0.11618350 ## ## $value ## [1] 1 ## ## $options ## NULL "],["paths.html", "Chapter 11 Paths 11.1 Diameter 11.2 Caminos y distancias", " Chapter 11 Paths Caminos de un vértice a otro o de grupos de vértices a otros. 11.1 Diameter El máximo camino más corto entre cualquier par de nodos. En grafos muy grandes indica la posibilidad de que la información se difunda más o menos fácilmente. El algoritmo tiene costo \\(O(n^3)\\). En Twitter hay cientos de millones de usuarios,… get_diameter diameter- el camino más largo entre dos nodos. plot(g1) diameter(g1) ## [1] 6 11.2 Caminos y distancias Distancia geodésica: El menor número de arcos a atravesar para conectar dos nodos. sp &lt;- shortest_paths(g1, from=&quot;1&quot;, to=&quot;10&quot;) sp$vpath ## [[1]] ## + 3/10 vertices, from 6050a01: ## [1] 1 5 10 sp1 &lt;- shortest_paths(g1, from=&quot;1&quot;, to=&quot;9&quot;) ## Warning in shortest_paths(g1, from = &quot;1&quot;, to = &quot;9&quot;): At core/paths/ ## dijkstra.c:442 : Couldn&#39;t reach some vertices. sp1$vpath ## [[1]] ## + 0/10 vertices, from 6050a01: distances(g1) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 0 1 1 2 1 2 3 1 1 2 ## [2,] 1 0 1 1 2 2 3 2 2 1 ## [3,] 1 1 0 1 1 1 2 2 2 2 ## [4,] 2 1 1 0 2 2 3 1 3 2 ## [5,] 1 2 1 2 0 2 3 2 2 1 ## [6,] 2 2 1 2 2 0 1 3 3 3 ## [7,] 3 3 2 3 3 1 0 4 4 4 ## [8,] 1 2 2 1 2 3 4 0 2 3 ## [9,] 1 2 2 3 2 3 4 2 0 3 ## [10,] 2 1 2 2 1 3 4 3 3 0 Relacionado con distancias: distance_table, mean_distance "],["clustering.html", "Chapter 12 Clustering 12.1 Transitivity", " Chapter 12 Clustering Whether your friends are likely to be friends. Grupos: Subconjunto de vértices que comparten características en común. Una primera forma es buscar los triángulos en el grafo. *La medida de clustering (transitividad) es la frecuencia relativa de triángulos cerrados. \\[C=\\frac{3*\\mbox{ número de triángulos }}{\\mbox{número de triples conectados}}\\] 12.1 Transitivity friends of friends to be friends and enemies of enemies to be enemies Probabilidad de que vértices adyacentes de un vértice estén conectados - se denomina también coeficiente de agrupación o clustering. transitivity, shortest_paths 12.1.1 Global clustering: transitivity(g1, type = &quot;global&quot;) ## [1] 0.2571429 12.1.2 Local clustering Fracción de triples conectados a través de cada vértice que son cerrados. transitivity(g1, type = &quot;local&quot;) ## [1] 0.2000000 0.3333333 0.3000000 0.3333333 0.3333333 0.0000000 NaN ## [8] 0.0000000 NaN 0.0000000 "],["otras-medidas-y-definiciones.html", "Chapter 13 Otras medidas y definiciones", " Chapter 13 Otras medidas y definiciones Densidad: Número de conexiones respecto al total de conexiones posibles. Un grafo completo tiene una densidad igual a 1 - edge_density. Popularidad: nodos que son centrales tienden a ser más populares. Cliques: todos con todos - clique_num(g, min=k) encuenta cliques con un mínimo de k vértices. Componentes: Una componente es el conjunto de vértices de la que tienen conexiones entre ellos. Una red puede tener varias componentes - components Nodos a distancia k - random_walk. Hub, Authorities - hub_score, authority.score un nodo se denomina hub tiene muchos enlaces de salida y se denomina authorities si tiene muchos de entrada. detección de comunidades: cluster_edge_betweenness "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
