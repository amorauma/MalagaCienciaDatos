
```{r, warning=FALSE, message=FALSE}
# Visualización de tablas desde Rmarkdown
#install.packages("kableExtra")
library(knitr)
library(kableExtra)
options(knitr.table.format = "html") 
library(igraph)
library(igraphdata)
library(tidyverse)
```

# Social Network Analysis

* **Disciplina con base sólida de Matemática Aplicada: Teoría de Grafos y Matemática Discreta. **

* Unida con Álgebra Lineal: las bases de Pagerank (algoritmo de Google) [The Mathematics of Google Search](http://pi.math.cornell.edu/~mec/Winter2009/RalucaRemus/Lecture3/lecture3.html).  


Describir las relaciones entre los elementos de una red y extraer conocimiento acerca de las estructuras sociales que existen en esa red. Tópico de enorme interés para extraer conocimiento de redes sociales **en cualquier área**. 

>> en una red los actores no intervienen aislados

>> decribir todos los actores intervinientes en las redes

>> redes de alta complejidad


Existen muy destacadas aplicaciones para SNA:

### Gephi

* [https://gephi.org](https://gephi.org)

* https://gephi.org/tutorials/gephi-tutorial-quick_start.pdf

> Exploratory Data Analysis: intuition-oriented analysis by networks manipulations in real time.

> Link Analysis: revealing the underlying structures of associations between objects.

> Social Network Analysis: easy creation of social data connectors to map community organizations and small-world networks.

> Biological Network analysis: representing patterns of biological data.

### Cytoscape

* [https://cytoscape.org](https://cytoscape.org)

>> Cytoscape is an open source software platform for visualizing molecular interaction networks and biological pathways and integrating these networks with annotations, gene expression profiles and other state data.

>> Library for visualization

>> 
 
## R for SNA
 
 
 Usaremos el paquete **igraph**. Nos servirá para analizar más adelante datos extraído de Twiter.



Ventajas de usar R:

-  **Reproducible research** no es posible con las aplicaciones GUI.

- Herramientas sólidas para manipular los datos. 

- Cada vez más paquetes diseñados para hacer de R una herramienta completa de análisis de redes. 

- Paquetes statnet y igraph. 

- Thomas Lin Pedersen ha publicado los paquetes tidygraph y ggraph, que aprovechan la potencia de igraph de forma coherente con el flujo de trabajo de tidyverse. 

- Crear gráficos de red interactivos con el marco htmlwidgets que traduce el código de R a JavaScript.
 
# Elementos de una red

- nodos o vértices de grafo (nodes, vertices)


```{r,echo=FALSE}
pel <- read.csv("data/peliculas.csv")
 
unique(c(pel$Actor.1,pel$Actor.2 ))

```

- arcos o enlaces  (edges, links)

```{r,echo=FALSE}
  
cbind(pel$Actor.1, pel$Actor.2)

```


Nodos y arcos pueden contender atributos adicionales con importante información: 


```{r,echo=FALSE}
grafo_peliculas <- graph.edgelist(as.matrix(pel[,c(1,2)]),directed = FALSE)

E(grafo_peliculas)$movies <- pel$Movie

E(grafo_peliculas)$movies
grafo_peliculas$layout <- layout_in_circle
 
 
plot(grafo_peliculas,vertex.size = 1, 
     vertex.color = "blue", 
     vertex.label.color = "black",  
     vertex.label.dist = 1,
     edge.label = E(grafo_peliculas)$movies,
     edge.label.cex = 0.5,
     edge.label.font =1,
     edge.arrow.size=0.4,
     edge.curved=0.3)

 
```
  
 





## Representación de redes 

### Grafos como listas de arcos

data.frame o matriz (si los datos del mismo tipo)  que contiene dos columnas:

- primera  columna:  nodos que son el origen de una conexión 
- segunda  columna:   nodos que son el destino de la conexión

Si el sentido es importante,  la red se denomina  dirigida, en otro caso, no dirigida. 



```{r,echo=TRUE,eval=TRUE}
alumnos1 <- c("Luis", "Ana", "Fran", "Pedro", "Laura", "Susana")
alumnos2 <- c("Juan", "Jose", "Amalia", "Lucía", "Maite", "Eduardo")

grupos <- data.frame(integrante1 = alumnos1, integrante2 = alumnos2, stringsAsFactors = F)

print(grupos)
str(grupos)

```


### Grafos como matrices

```{r,echo=TRUE,eval=TRUE}
# Se pueden usar matrices 'sparse'
A <- rbind(c(0,1,0), c(1,0,1), c(1,0,0))
nodeNames <-  c("A","B","C")
dimnames(A) <-  list(nodeNames, nodeNames)
A
str(A)

```

> Caminos de longitud dos, tres, etc:

```{r,echo=TRUE,eval=TRUE}
# Multiplicación matricial
A2 <- A %*% A
A2

A3 <- A %*% A %*% A 
A3
```

> Representado arcos:

```{r,echo=TRUE,eval=TRUE}
Arcos <- rbind(c("A","B"), c("B","A"), c("B","C"), c("C","A"))
Arcos
```



<!-- ### Usando tidverse -->


<!-- ```{r,echo=TRUE,eval=TRUE} -->
<!-- alumnos1 <- c("Luis", "Ana", "Fran", "Pedro", "Laura", "Susana") -->
<!-- alumnos2 <- c("Juan", "Jose", "Amalia", "Lucía", "Maite", "Eduardo") -->

<!-- node_list_alumnos <- tibble(id = unique(c(alumnos1,alumnos2))) -->
<!-- node_list_alumnos -->
<!-- edge_list_alumnos <- tibble(from = alumnos1, to = alumnos2) -->
<!-- edge_list_alumnos -->


<!-- ``` -->



# Introducción a **igraph**

```{r,echo=TRUE,eval=TRUE}
# Instalar la primera vez - descomentar
#install.packages("igraph")
#install.packages("igraphdata")
library(igraph)
library(igraphdata)


# Importar la red de datasets ya establecidos: igraphdata

# Limpia la memoria - Cuidado - borra todas las variables
rm(list=ls())

#Lista de datasets de redes de nodos en igraph
# data(package="igraphdata") 
 
# El paquete tiene un conjunto de datasets
# Carga data set y vemos que contiene 
#Red social entre miembros de club de karate de universidad 
data(karate,package="igraphdata") 
plot(karate)
```

## Acceder a elementos de grado

```{r}
# UKfaculty: Friendship network of a UK university faculty
data(UKfaculty) 
plot(UKfaculty)
UKfaculty
V(UKfaculty)
E(UKfaculty)
V(UKfaculty)
str(UKfaculty)
head(E(UKfaculty)$weight)
head(V(UKfaculty)$Group)
```



## Construir/Modificar un grafo

> Añadir arcos a un grafo vacío:

```{r,echo=TRUE,eval=TRUE}
# Un grafo dirigido  vacío  
g <- make_empty_graph(n = 0, directed = TRUE)
g
g <- g + vertices(c("A","B","C"))
g

# Arcos:  A to C ,  B to C
g <- g + edges(c("A","C", "B","C")) 
g

# Eliminar arco  A
g <- g - V(g)["A"]
g
# Eliminará todos los arcos conectados con A
```

> Lista de arcos: graph() and get.edgelist():

```{r,echo=TRUE,eval=TRUE}
# Un grafo dirigido  vacío  

#     graph() id desde   1. 
g1 <- graph( c(1,2, 1,3, 2,3, 3,4 ));g1
summary(g1)
plot(g1)

# El parámetro "directed" a  FALSE para
# grafos no dirigidos.  

g2 <- graph( c(1,2, 1,3, 2,3, 3,4 , 3, 5, 1, 3), directed=FALSE); g2 
summary(g2)
plot(g2)

#Obtener la lista de arcos a partir de un grafo   
edgelist<-get.edgelist(g2) ; edgelist
edgelist <- as_edgelist(g2) ; edgelist

# Obtener el grafo a partir de la lista de arcos
g3<-graph( t(edgelist));  g3;  plot(g3)
g3<-graph( edgelist);  g3;  plot(g3)

# algunos parámetros de plot 

plot(g3, 
     vertex.color="green", 
     edge.arrow.size=0.5, 
     vertex.size=25,
     edge.curved=0.5,
     layout_as_star=TRUE)
```

> Matrices de adyacencia: graph.adjacency(), get.adjacency()

```{r,echo=TRUE,eval=TRUE}
adjm_u<-matrix(
  c(0, 1, 0, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 
  0, 1, 0, 1, 0, 0, 
  0, 0, 1, 0, 1, 1, 
  1, 1, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0),
  nrow=6, 
  ncol=6, 
  byrow = TRUE)
#grafo a partir de matriz de adyacencia
g_adj_u <- graph.adjacency(adjm_u, mode="undirected") 

plot(g_adj_u)
# Matriz de adyacencia a partir de grafo
A <- get.adjacency(g_adj_u); A
A <- as_adjacency_matrix(g_adj_u, sparse = FALSE)
A

```

> Grafo a partir de data frame

```{r,echo=TRUE,eval=TRUE}
# Primero, crear el data frame
node1 = c("Ella", "Tu", "El"); node2 = c("El", "Ella", "Tu")
weight = c(10, -2, 3)
df = data.frame(node1, node2, weight); df
# Crear el grafo 
g <- graph.data.frame(df, directed=FALSE); g
plot(g)
# Si se conocen los vértices
# g <- graph.data.frame(df, vertices=listvertices, directed=FALSE);g

# Obtener los nombres de los nodos
V(g)$name 

# Obtener los pesos de los arcos
E(g)$weight  
 


```

> Grafo a partir de literales

```{r,echo=TRUE,eval=TRUE}
#?graph_from_literal

g <- graph_from_literal(A--C, A-+D, C-+A, , D-+C)
g
plot(g)

#IGRAPH DN-- 4 4 -- 
#+ attr: name (v/c)
#+ edges (vertex names):
#[1] A->D D->C D->B B->A

 G3 <-graph_from_literal(A-B, B -+C)
 plot(G3)
 G3 <-graph_from_literal(A-B, B -C)
 plot(G3)

```


>> grafo aleatorio

```{r}
g_random <- sample_gnp(10, 0.2, directed = FALSE, loops = FALSE)
plot(g_random)
```


# Visualización

Buscar ayuda de los comandos **plot.igraph**, **igraph.plotting**.

A continuación dibujamos algunos grafos interesantes:

```{r,echo=TRUE,eval=TRUE}
#library(igraph)
# Trees
g <- make_tree(27, children=3)
g; plot(g)

# Cliques 
g <- make_full_graph(n=6)
g; plot(g)

# Lattices
g <- make_lattice(dimvector = c(5,5), circular = FALSE)
V(g)$label <- NA
g; plot(g)

#Stars
g <- make_star(n=10,mode = "undirected")
g;  plot(g)


```

> Anillo con conexiones cruzadas:

```{r,echo=TRUE,eval=TRUE}
g <- make_ring(10, directed=TRUE, mutual=TRUE)

V(g)$name <- LETTERS[1:10]

g <-  g + edges(9,5, 7,1, 1,5)

plot(g)

```

## Layout

Un *layout* es un conjunto de coordenadas x,y preestablecidas. Se pueden especificar manualmente o usando **layout_functions**

>> Determina la posición de los nodos en la red. Hay layouts ya diseñados o puedes diseñarlo desde 0. 

>> Intentar minimizar cruces de arcos. 

>> Algoritmos que lo consiguen: por ejemplo -  Kamada Kawai algorithm, the Fruchterman Reingold algorithm, etc. 



```{r,echo=TRUE,eval=TRUE}

Lykamada <- layout.kamada.kawai(g)
plot(g, layout=Lykamada)

Lyfruchtermant <- layout.fruchterman.reingold(g)
plot(g, layout=Lyfruchtermant)

lo <- layout_in_circle(g)
head(lo, n=4) 

# lo es una matriz de coordenadas  
lo
plot(g, layout=lo)

# See ?layout_ for a full list

# Para redes tipo árbol:  layout_as_tree
gTree <- make_tree(15)
plot(gTree, layout=layout_as_tree(gTree, root = 1))

# layout como un grid
plot(g, layout=layout_on_grid(g))
```


Mallas:

```{r}
library(igraph)
#Buscar en ayuda
#?igraph::layout  
g <- make_tree(15)
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g)
plot(g, layout=layout1)


# Otra malla diferente
plot(g, layout=layout.kamada.kawai)
# Malla interactiva - Ejecutar en consola
# tkplot(g, layout=layout.kamada.kawai)
```

## Dibujar grafos ponderados

```{r, eval=FALSE}
V(g)$label.cex <- ...
V(g)$label.color <- ...
V(g)$frame.color <- ... 
E(g)$color <- rgb(....
E(g)$width <-    
  
```


## Cambiar aspecto y propiedades de un grafo

```
V(g)$shape 
V(g)$size
V(g)$color
```

* vertex.shape
* vertex.color
* vertex.size  
* set_edge_attr
* set_vertex_attr
* set_graph_attr

```{r}
plot(g, vertex.size = 20)
plot(g, vertex.size = 10, vertex.color = "blue", vertex.frame.color = NA, vertex.label = NA)
plot(g, vertex.size = 10, vertex.color = "blue", vertex.frame.color = NA, vertex.label.cex = .7,  vertex.label = NA, edge.curved = .5, edge.arrow.size = .3, edge.width = .7)
```

Note: colores en R [http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)



```{r}
library(tidyverse)
g1random <- sample_gnp(10, p=0.4)

V(g1random)[1]$color <- "yellow" 

g1random %>%
  set_edge_attr("color",value = "blue") %>%
 plot()
```

## Ejemplos - plantillas

> Plot vocales como rectángulos

```{r,echo=TRUE,eval=TRUE}
g <- make_ring(10, directed=TRUE, mutual=TRUE)

V(g)$name <- LETTERS[1:10]

g <-  g + edges(9,5, 7,1, 1,5)

plot(g)
vowel <- V(g)$name %in% c("A","E","I","O","U") + 1 # gives 1 or 2
plot(g, layout=lo, vertex.shape=c("circle", "square")[vowel])
#colores
plot(g, layout=lo, vertex.color=c("tomato2", "royalblue")[vowel])
#tamaño
plot(g, layout=lo, vertex.size=c(15,30)[vowel])
#Propiedades usando atributos

V(g)$shape <- "circle" # Aplicado a todos los vértices
V(g)$size <- 15
V(g)$color <- "orange"
isVowel <- V(g)$name %in% c("A","E","I","O","U")
# Sobreescribir los nodos vocales 
V(g)[isVowel]$shape <- "square"
V(g)[isVowel]$color <- "royalblue"
V(g)[isVowel]$size <- 25

plot(g, layout=lo)

```

> Propiedades de los arcos

```{r,echo=TRUE,eval=TRUE}
E(g)$width <- 1
v1 <-V(g)[isVowel]
v1
E(g)[v1  %--%  v1]$width <- 4

# Ver http://igraph.org/r/doc/igraph-es-indexing.html

plot(g, layout=lo)

#Arcos curvados
plot(g, layout=lo, edge.curved=0.3*which_mutual(g))

```

> Agrupaciones por índices:

```{r,echo=TRUE,eval=TRUE}
groupList <- list(vowelGroup = which(isVowel),
                  constGroup1 = c(2,3,4),
                  constGroup2 = c(6,7,8))

groupColours <- c(rgb(0,0.3,1,0.5),
                  rgb(0.8,0.4,0.1,0.5),
                  rgb(0.8,0.4,0.1,0.5))
plot(g, layout=layout_with_fr, # Fruchterman?Reingold layout
     mark.groups=groupList, # Mark the groups
     mark.col= groupColours,
     # Eliminar el borde
     mark.border = NA, 
     edge.curved=0.1*which_mutual(g))
text(0.45,0.1,"Vocales", cex=1.5)
text(0.5,0.9,"Grupo consonantes 1", cex=1.5)
text(-0.8,-1,"Grupo consonantes 2", cex=1.5)

```

 
# De Twitter

-   El primer paso será extraer los términos usando las técnicas de text mining y crear una matriz de términos (DTM - Document Term Matrix:).
-   Los documentos serían los tweets y los términos serían las palabras o grupos de palabras destacadas en los datos extraidos.
-   **Objetivo: Construir una red de términos (personas) basada en sus co-ocurrencias en los mismos tweets (pertenencia a los mismos grupos)**. 
 
# Exportar grafos 

**igraph** permite importar y exportar de/desde un considerable número de formatos. Se usan los comandos **read_graph** y **write_graph**. Un formato abierto (open) es *graphml*.

```{r,echo=TRUE,eval=TRUE}
write_graph(g, "gr1.graphml", format="graphml")

```

Otros formatos:

-   edgelist: Fichero de texto con arcos en cada línea.

-   pajek: Pajek es un programa popular en Windows para análisis de redes.\

-   gml: Graph Modelling Language es uno de los formatos abiertos más populares.\

-   graphml: Graph Markup Language es un formato abierto basado en XML.

-   dot: Formato usado por GraphViz.

-   \*\* Gephi: Para exportar al formato nativo GEXF de Gephise usa el paquete rgexf al que puede convertirse desde un objeto igraph \*\*

Referencias: 

* [https://www.r-project.org/nosvn/conferences/useR-2010/slides/Zhang.pdf](https://www.r-project.org/nosvn/conferences/useR-2010/slides/Zhang.pdf)
* [https://programminghistorian.org/en/lessons/temporal-network-analysis-with-r](https://programminghistorian.org/en/lessons/temporal-network-analysis-with-r)



# Analysis of the Networks to extract knowledge. 


>> Goal of a SNA proyect

[http://snap.stanford.edu/class/cs224w-2015/slides/06-applicationsI.pdf](http://snap.stanford.edu/class/cs224w-2015/slides/06-applicationsI.pdf)

* Locate people in the network for...

  1. higher compensation
  2. positive performance evaluations  
  3. more promotions
  4. more good ideas


> Ego network is a special type of network consisting of one central node and all other nodes directly connected to it. The central node is known as ego, while the other surrounding nodes directly connected to it are known as alters.

 

* [https://medium.com/applied-data-science/the-google-vs-trick-618c8fd5359f](https://medium.com/applied-data-science/the-google-vs-trick-618c8fd5359f)

* [http://olizardo.bol.ucla.edu/classes/soc-111/lessons-winter-2022/5-lesson-egonet-metrics.html](http://olizardo.bol.ucla.edu/classes/soc-111/lessons-winter-2022/5-lesson-egonet-metrics.html)

Vamos a usar este grafo como ejemplo de las medidas de bondad del grafo.

```{r}
library(igraph)
g1 <- graph( c(1,2, 1,3, 2,3, 
               3,4, 3,5, 1,5,
               4,2, 3,6, 4,8,
               8,1, 9,1, 10,2, 
               7,6, 5,10))
g1
summary(g1)
plot(g1)
```

**Vértices, arcos**.

```{r}
class(g1)
V(g1)
V(g1)[1]
E(g1)
E(g1)[1]
class(V(g1))
class(E(g1))
```

# Centrality

Importancia de los nodos en un grafo.

-   Número de arcos de entrada-salida de los nodos.
-   Redes con alta centralidad tienen pocos nodos con muchas conexiones. 
- Redes con baja centralidad tienen muchos nodos con similar o menos conexiones.
-   Ver <https://en.wikipedia.org/wiki/Centrality#PageRank_centrality>

## Degree

Número de arcos conectados a un vértice. Señala la importancia de un vértice o el nivel de actividad del vértice en la red.

-   Cómo de central es un nodo en la red

-   Cuántos arcos de entrada-salida tiene o con cuántos nodos se conecta directamente via un arco.

> > `centr_degree`, `igraph::degree`

```{r}
g1
plot(g1)
igraph::degree(g1)
igraph::degree(g1, mode="in")
igraph::degree(g1, mode="out")
deg <- centr_degree(g1)
deg
```

## Betweenness

Mide el grado en el que la información fluye a través de un vértice particular y su importancia relativa como un intermediario en la red.

Describe nodos que son conexiones clave o puentes entre grupos de nodos.

-   El número de caminos más cortos que pasan por un nodo dado (medida relativa) - la suma de las longitudes de los caminos más cortos entre otros nodos pasando por el nodo, dividida por las longitudes de camino más cortas (no necesariamente a través del nodo) entre los otros nodos.

> > `igraph::betweenness`

```{r}
igraph::betweenness(g1)
 
```

-   Por el vértice 6 no pasa ningún *camino más corto* entre dos vértices.
-   Por el vértice 3 pasan 25 *caminos más cortos* entre dos vértices.
-   ...

## Edge_betweenness

Similar al anterior pero teniendo en cuenta cada arco.

> > `igraph::edge_betweenness`

```{r}
 
g1 <- set.edge.attribute(g1, "weight",  value= 1)
bg <- edge_betweenness(g1)
plot(g1, edge.label = bg)
```

## Closeness

Distancia a otros nodos. Un nodo con valor alto de este estimador es más central y puede difundir la información a muchos otros nodos.

-   Se obtiene como 1 divido por la suma de las distancias geodésicas desde un vértice al resto. Alcanzará su valor máximo cuando un vértice esté conectado a todos los demás. Longitud media de los caminos más cortos (geodésicos).


-   Mide cuantos pasos se requieren desde un vértice para alcanzar el resto de vértices de la red.

-   Caminos cortos entre vértices señalan que estos están cercanos unos a otros.

> > `centr_clo`, `igraph::closeness`

```{r}
 igraph::closeness(g1)
```

## Eigenvector

No todas las conexiones tienen la misma importancia - medida de la importancia de un nodo.

-   La medida *Eigenvector Centrality* se calcula como el autovalor de mayor módulo de la matriz de adyacencia que contiene los pesos.

-   *a high score to vertices that either have a lot of connections, or are connected to someone with a lot of connections*

> > Eigenvector Centrality: `eigen_centrality`

```{r}
eigen_centrality(g1)
```

## Pagerank

Algoritmo de Google para realizar un ranking con la importancia de los resultados de la búsqueda.

Nodos son más importantes si tienen muchos enlaces de entrada.

> > `page.rank`

```{r}
page.rank(g1)
```

# Paths

Caminos de un vértice a otro o de grupos de vértices a otros.

## Diameter

El máximo camino más corto entre cualquier par de nodos. En grafos muy grandes indica la posibilidad de que la información se difunda más o menos fácilmente. El algoritmo tiene costo $O(n^3)$. En Twitter hay cientos de millones de usuarios,...

> > `get_diameter`

> > `diameter`- el camino más largo entre dos nodos.

```{r}
plot(g1)
diameter(g1)
```

## Caminos y distancias

**Distancia geodésica**: El menor número de arcos a atravesar para conectar dos nodos.

```{r}
sp <- shortest_paths(g1, from="1", to="10")
sp$vpath
sp1 <- shortest_paths(g1, from="1", to="9")
sp1$vpath
distances(g1)
```

Relacionado con distancias:

> > `distance_table, mean_distance`

# Clustering

*Whether your friends are likely to be friends*.

**Grupos**: Subconjunto de vértices que comparten características en común.

-   Una primera forma es buscar los triángulos en el grafo. \*La medida de clustering (transitividad) es la frecuencia relativa de triángulos cerrados.

$$C=\frac{3*\mbox{ número de triángulos }}{\mbox{número de triples conectados}}$$

## Transitivity

*friends of friends to be friends and enemies of enemies to be enemies*

Probabilidad de que vértices adyacentes de un vértice estén conectados - se denomina también coeficiente de agrupación o *clustering*.

> > `transitivity`, `shortest_paths`

### Global clustering:

```{r}
transitivity(g1, type = "global")
```

### Local clustering

Fracción de triples conectados a través de cada vértice que son cerrados.

```{r}
transitivity(g1, type = "local")
```

# Otras medidas y definiciones

-   Densidad: Número de conexiones respecto al total de conexiones posibles. Un grafo completo tiene una densidad igual a 1 - `edge_density`.

-   Popularidad: nodos que son centrales tienden a ser más populares.

-   Cliques: todos con todos - `clique_num(g, min=k)` encuenta cliques con un mínimo de k vértices.

-   Componentes: Una componente es el conjunto de vértices de la que tienen conexiones entre ellos. Una red puede tener varias componentes - `components`

-   Nodos a distancia k - `random_walk`.

-   Hub, Authorities - `hub_score, authority.score` un nodo se denomina hub tiene muchos enlaces de salida y se denomina authorities si tiene muchos de entrada.

-   detección de comunidades: `cluster_edge_betweenness`



