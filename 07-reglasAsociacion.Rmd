# Reglas de Asociación 

## Introducción

- Aprendizaje no supervisado: técnica que permite un aprendizaje a partir de observaciones que permite extraer patrones, tendencias y realizar predicciones - **sin entrenamiento**. 
- Entre los problemas más relevantes - **predición de comportamiento de clientes, tendencias de compras**: tiendas online, servicios online que ofrecen música, películas, etc. 
- La realidad actual es que hay mucha competencia, muchos servicios similares, mercados online, etc.
- Objetivo: **Atraer clientes es la clave**. 
- Medios: datos recolectados de los consumidores, de los usuarios de los servicios, características de los consumidores extraidas de los datos recolectados, patrones previos de compra o de uso, etc.
- Herramientas: Métodos de Ciencia de Datos - **búsqueda de patrones frecuentes, reglas, etc.**

Los métodos usados en esta área deben analizr los datos almacenados para diseñar sistemas recomendadores con los que:

- Ayudar a personalizar los servicios y la experiencia de compra, adivinar y sugerir tendencias de compra a partir de *likes, dislikes*. 
- Controlar las horas punta de los servicios.
- Analizar combinaciones de productos que la gente suele comprar juntas.
- Analizar revisiones y precios que la competencia ofrece por los mismos productos

Los problemas en este área surgen del llamado **Market Basket Analysis** que se enfrenta a cómo realizar recomendaciones basadas en productos. Las soluciones para este problema pueden usarse en otros problemas similares: recomendaciones de intereses de las personas, etc.

Las técnicas más importantes son:

- Evaluación de la matriz de contingenica de los productos.
- Generación de itemsets frecuentes.
- Extracción de reglas de asociación.

### Detectando y prediciendo tendencias

- Tendencia: patrón específico o comportamiento de compra-venta que aparece en un periodo de tiempo en una tienda. 
- ¿Cómo detectar?: Almacenar todas las transacciones que se realicen en la tienda.
  * items comprados
  * stocks
  * combinaciones de items comprados juntos
  * transacción de cada venta realizada
- ¿Cómo tratar los datos?: 
  * pre-procesar
  * normalizar
  * agregar
- Aplicar algoritmos: localizar patrones y tendencias
- Recomendar: usar patrones y tendencias para sugerir nuevas compras.

El principal método para conseguir todo esto está basado en el problema denominado **Market Basket Analysis**.  Estos métodos están fundamentados en estadística basado en probabilidad y nociones probabilísticas como:
  * soporte
  * confianza
  * lift, etc.
  
Objetivo: **¿Qué items (productos) se han comprado más frecuentemente?**


## Reglas de Asociación de transacciones  


>> Explorando el dataset  **Adult**

```{r cargardataset,echo=TRUE}
#install.packages(arules)
library(arules)
data("Adult")
length(Adult)
dim(Adult)
Adult
inspect(Adult[1:2])
```
 

Para calcular las reglas de asociación: 

```{r extraer_reglas,echo=TRUE}
data("Adult")
 rules <- apriori(Adult,  parameter = list(supp = 0.5, conf = 0.9,   
target = "rules")) 
summary(rules) 
inspect(head(rules))
```

### Parámetros de **apriori**

> parameter: lista con las restricciones en el proceso de extracción

  - *supp* o *support*
  - *conf* o *confidence*
  - *minlen* - máximo número de items en itemset
  - *maxlen* - máximo número de items en itemset
  - *maxtime* - límite de tiempo
  - *target* - indicar qué tipo de asociaciones queremos extraer: "rules", "frequent itemsets", "maximally frequent itemsets", "closed frequent itemsets".
   
```{r apriori_parameters,echo=TRUE}
rules <- apriori(Adult,  parameter = list(supp = 0.5, conf = 0.9,minlen=2)) 
inspect(tail(rules))
patterns <- apriori(Adult,  parameter = list(supp = 0.5, conf = 0.9,maxlen=10, target="frequent itemsets")) 
summary(patterns)
inspect(tail(patterns))
```

                 
> appearance: especificar restricciones en la extracción de las asociaciones. 

```{r apriori_restricciones,echo=TRUE}
rules1 <- apriori(Adult,  
                 parameter = list(supp = 0.5, conf = 0.9), 
                 appearance = list(items = c("income=small", "sex=Male"))) 

inspect(head(rules1)) 
                 
rules2 <- apriori(Adult,  
                 parameter = list(supp = 0.5, conf = 0.9), 
                 appearance = list(none = c("income=small", "sex=Male"))) 
    
inspect(head(rules2))                              
```

## Reglas de Asociación - preprocesamiento


>> Explorando el dataset  **AdultUCI** 

Contiene los datos del dataset que originalmente se llamó 'Census Income' Database en formato data.frame.  
 
El dataset **Adult** del apartado anterior tiene los datos preparados para el cómputo de las reglas. 
El tipo de datos de este dataset es  **transactions** que es adecuado para el paquete arules. 

El dataset AdultUCI:

```{r cargandolibrerias,echo=TRUE}
library(arules)
data("AdultUCI")
#View(AdultUCI)
str(AdultUCI)
```

En la mayoría de los datasets es necesario un primer paso de preprocesamiento. 

A continuación aplicaremos el preprocesamiento a AdultUCI hasta convertirlo en transacciones que arules maneja adecuadamente. 

### Discretización de items
> Borrar algunas columnas que no son interesantes: {\tt fnlwgt, education-num}

```{r borrando columna,echo=TRUE}
AdultUCI$fnlwgt <-NULL  
## o  AdultUCI[["fnlwgt"]] <- NULL

AdultUCI$`education-num` <- NULL 
```

> Convertir a discretos valores numéricos: *age*,  *hours-per-week*, *capital-gain*, *capital-loss*}.

Usaremos comandos {\tt cut,ordered} para hacerlo. A continuación un ejemplo de cómo funcionan estos dos comandos:

```{r cut,echo=TRUE}
# ejemplo de funcionamiento de cut y ordered
v <- 1:100
v2 <- cut(v,c(0,25,50,75,100),labels=c("bajo","medio","alto","muyalto"))
v3 <- ordered(v2)
```


Aplicamos estas funciones a AdultUCI:

```{r discretizar,echo=TRUE}

AdultUCI$age <- ordered(cut(AdultUCI[[ "age"]], c(15,25,45,65,100)),
  labels = c("Young", "Middle-aged", "Senior", "Old"))

AdultUCI[[ "hours-per-week"]] <- ordered(cut(AdultUCI[[ "hours-per-week"]],
  c(0,25,40,60,168)),
  labels = c("Part-time", "Full-time", "Over-time", "Workaholic"))

AdultUCI[[ "capital-gain"]] <- ordered(cut(AdultUCI[[ "capital-gain"]],
  c(-Inf,0,median(AdultUCI[[ "capital-gain"]][AdultUCI[[ "capital-gain"]]>0]),
  Inf)), labels = c("None", "Low", "High"))

AdultUCI[[ "capital-loss"]] <- ordered(cut(AdultUCI[[ "capital-loss"]],
  c(-Inf,0, median(AdultUCI[[ "capital-loss"]][AdultUCI[[ "capital-loss"]]>0]),
  Inf)), labels = c("None", "Low", "High"))


```

  
Llamamos a **apriori**:

```{r aprioriNoParametros,echo=TRUE}
reg <- apriori(AdultUCI)
inspect(head(reg))
```

### Tipo de dato *transactions*

Ver https://www.r-bloggers.com/data-frames-and-transactions/}

Comparamos AdultUCI que hemos procesado con Adult.

```{r convirtiendoadult,echo=TRUE}
Adult1 <- as(AdultUCI, "transactions")
class(Adult1)
length(Adult1)
dim(Adult1)
Adult1
inspect(Adult1[1:2])
```



```{r innspeccionandoAdult,echo=TRUE}
data("Adult")
class(Adult)
length(Adult)
dim(Adult)
Adult
inspect(Adult[1:2])
```

### Métodos de arules

* summary(): Visión del conjunto de reglas. 
* length(): Número de reglas. 
* items(): Elementos involucrados. 
* sort(): Ordenar. 
* subset(): Elementos involucrados.  (see help(subset). Seleccionar reglas que cumplan ciertos criterios. 
* union(), intersect(), setequal(), match()  (usar ayuda help(xxx) ).  
* write(): Escribir reglas con formato más adequado.

 

```{r operacionesReglas,echo=TRUE, eval=FALSE}
data("Adult")
r1 <- apriori(Adult[1:1000], parameter = list(support = 0.5))
r2 <- apriori(Adult[1001:2000], parameter = list(support = 0.5))
#Convertir en un dataframe
dfr1 <-DATAFRAME(r1)
r_comb <- c(r1, r2)
duplicated(r_comb)
intersect(r1,r2)
union(r1,r2)
lhs(reglas1)
rhs(reglas1)
class(lhs(reglas1))
```


## Ejercicio en Laboratorio

Utilizar con el dataset **Adult** los métodos y operaciones vistos en el presente documento.   


## arulesViz
 
Vamos a usar el dataset Groceries para ver los comandos de visualización de reglas de asociación más interesantes.  

Extraemos las reglas:
```{r}
library(arules)
library(arulesViz)
data(Groceries)
rules <- apriori(Groceries, parameter=list(support=0.001, confidence=0.5))
rules
inspect(head(rules))
```

El comando básico de visualización de reglas es **plot**. Mostramos distintas opciones de uso de plot (colores).
```{r}
plot(rules)
library(colorspace)  
plot(rules, control = list(col=sequential_hcl(100)))
plot(rules, col=grey.colors(50, alpha =.8))
```

Opción de visualización interactiva:

```{r,eval=FALSE}
#Ejecutar en vuestro ordenador
sel <- plot(rules, engine = "interactive")
plot(rules, engine = "htmlwidget")
```

Representación matricial de las reglas:

```{r}
subrules <- subset(rules, lift>8)
subrules
plot(subrules, method="matrix")
#plot(subrules, method="matrix", engine = "3d")
#plot(subrules, method="matrix", shading=c("lift", "confidence"))
```


E interactiva:

```{r, eval=FALSE}
# Ejecutar en vuestro ordenador
plot(subrules, method="matrix", engine="interactive")
plot(subrules, method="matrix", engine="htmlwidget")
```

Representación matricial mostrando los items:

```{r, eval=FALSE}
# Ejecutar en vuestro ordenador
plot(subrules, method="grouped matrix")
plot(subrules, method="grouped matrix", 
     col = grey.colors(10), 
     gp_labels = gpar(col = "blue", cex=1, fontface="italic"))
#sel <- plot(rules, method="grouped", engine = "interactive")
```

Representación mediante grafos de las reglas (solo para conjuntos pequeños de reglas):

```{r}
subrules2 <- sample(subrules, 5)
plot(subrules2, method="graph")
plot(subrules2, method="graph", 
     nodeCol = grey.colors(10), edgeCol = grey(.7), alpha = 1)
```

El paquete Graphviz permite una mejor visualización:
  
```{r}
plot(subrules2, method="graph", engine="graphviz")
```

Permite visualización dinámica:
```{r,eval=FALSE}
# Ejecutar en local
plot(subrules2, method="graph", engine="htmlwidget")
plot(subrules2, method="graph", engine="htmlwidget", 
     igraphLayout = "layout_in_circle")
```



## Construyendo un sistema recomendador
 
El dataset *lastfm.csv* del CV incluye las transacciones recogidas en una radio online que almacena el identificador del usuario, artista, sexo del usuario y el país. 

**Objetivo**: Construir un sistema de recomendación de  grupos de música a los usuarios a partir de dataset anterior.  

```{r cargodataset,echo=TRUE}
library(arules)
lastfm <- read.csv("data/lastfm.csv")
lastfm[1:20,]
length(lastfm$user)   ## 289,955 filas
class(lastfm$user)
# Necesitamos convertir este atributo a factor
#para poder analizarlo con paquete {\tt arules}

lastfm$user <- factor(lastfm$user)
# Ejecuta en tu ordenador
# levels(lastfm$user)  ## 15,000 users
# levels(lastfm$artist)  ## 1,004 artists
```


Llamamos a **apriori**:

```{r apriori, echo=TRUE}
reglas1 <- apriori(lastfm,parameter=list(support=.01, confidence=.5))
inspect(reglas1)
```

Comentario: En versiones anteriores de arules el anterior comando daba error. Teníamos que convertir a factor las variables discretas. Es un paquete *vivo* que va evolucionando día a día.

<!-- El dataset no es de tipo transacciones.  -->

<!-- ## Preprocesamiento -->

<!-- Realizamos el preprocesamiento para poder usar apriori.   -->


<!-- ```{r} -->
<!-- lastfm$sex <- factor(lastfm$sex) -->
<!-- lastfm$country <- factor(lastfm$country) -->

<!-- reglas1 <- apriori(lastfm, parameter=list(support=.01, confidence=.5)) -->
<!-- inspect(head(reglas1)) -->
<!-- ``` -->

**¿Cual es la recomendación que podemos obtener con estas reglas?**

No es el tipo de reglas que queremos obtener para nuestro sistema de recomendación. 

Los datos deben ser manipulados para poder encontrar lo que nos interesa.  Usaremos los Comandos: **split, lapply**.

Primero me quedo con una lista de lo que escucha cada usuario:

```{r split, echo=TRUE}
lista.musica.por.usuario <- split(x=lastfm[,"artist"],f=lastfm$user)
lista.musica.por.usuario[1:2]
```

A continuación: 

- Un grupo/cantante podría estar dos veces en un usuario: eliminar repeticiones
- Convertir a formato transacciones
- Mirar la música escuchada por los primeros usuarios

```{r atransacciones, echo=TRUE}
## Eliminar duplicados  
lista.musica.por.usuario <- lapply(lista.musica.por.usuario,unique)

# Convertimos en transacciones la lista de música.
lista.musica.por.usuario1 <- as(lista.musica.por.usuario,"transactions")

lista.musica.por.usuario[1:5]

# en la versión actual de R esto va bien
#error ¿? (en versiones anteriores de R daba error, si os pasa intentar siguientes comandos)
#lista.musica.por.usuario2 <- as(lapply(lista.musica.por.usuario, "[[", 1), "transactions")
#lista.musica.por.usuario2
```

Visualizamos lo que hemos conseguido hasta el momento:

```{r visualizartransacciones, echo=TRUE}
str(lista.musica.por.usuario1)
write(head(lista.musica.por.usuario1))
write(head(lista.musica.por.usuario1),format="single")
```

Es una lista de transacciones - clase de datos definida en arules. Calculamos la frecuencia relativa de las canciones escuchadas:

```{r itemfrequency, echo=TRUE}
itfreq1  <-itemFrequency(lista.musica.por.usuario1)
head(itfreq1)
```

*itfreq1*:

- es una vector numérico 
- los nombres de la lista (names(itfreq),  los nombres de cada grupo )
- cada posición por tanto es la frecuencia del grupo de esa posición

Dibujar las frecuencias  usando la lista de transacciones obtenida:

```{r itemFrequencyPlot, echo=TRUE}
itemFrequencyPlot(lista.musica.por.usuario1,support=.08,cex.names=1)
```

Y obtenemos las reglas de asociación con soporte 0.1 y confianza 0.5:

```{r aprioricontrans, echo=TRUE}
reglas2 <- apriori(lista.musica.por.usuario1,parameter=
                     list(support=.01, confidence=.5))
reglas2
inspect(reglas2)
```

 

Primero nos quedamos con las reglas más interesantes. Filtramos aquellas con lift mayor que 1:

```{r reglasinteresantes, echo=TRUE}
inspect(subset(reglas2, subset=lift > 1))
```

Ordenamos por confianza estas reglas anteriores:

```{r  filtrar, echo=TRUE}
inspect(sort(subset(reglas2, subset=lift > 1), by="confidence"))

```

**¿Recomendación a usuarios que escuchan Coldplay?**:
```{r  recomendacion, echo=TRUE}
r1 <-subset(reglas2, subset = lhs %ain% 
         c("coldplay"))
inspect(r1)
```


Probad con otros grupos. 



<!-- # Afinidad -->

<!-- Se define la afinidad entre dos items  (Agrawal 2002) como   -->

<!-- $$A(i,j)=\frac{sup({i,j}))}{sup({i})+sup({j})-sup({i,j})}$$ -->

<!-- o lo que es lo mismo: -->
<!-- $$A(i,j)=\frac{\mid A \cap B}{\mid A \cup B\mid }$$ -->

<!-- ```{r} -->
<!-- inspect(head(lista.musica.por.usuario1)) -->
<!-- afi <- affinity(head(lista.musica.por.usuario1)) -->
<!-- View(afi) -->
<!-- image(afi) -->
<!-- ``` -->


<!-- Por un lado se  muestra la matriz de afinidad.  -->
<!-- La imagen  muestra la afinidad que tiene cada ítem con cada ítem del dataset de transacciones, cuanto mas se acerca al blanco mas afinidad existe entre ambos ítems. -->



