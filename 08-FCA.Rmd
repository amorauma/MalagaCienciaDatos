
# Formal Concept Analysis

> > Port-Royal logic (traditional logic): formal notion of concept, Arnauld A., Nicole P.: La logique ou l'art de penser, 1662 (Logic Or The Art Of Thinking, CUP, 2003): concept = extent (objects) + intent (attributes)

> > G. Birkhoff (1940s): work on lattices and related mathematical structures, emphasizes applicational aspects of lattices in data analysis.

> > Barbut M., Monjardet B.: Ordre et classiffication, algebre et combinatoire. Hachette, Paris, 1970.

> > Wille R.: Restructuring lattice theory: an approach based on hierarchies of concepts. In: I. Rival (Ed.): Ordered Sets. Reidel, Dordrecht, 1982, pp. 445-470.

> > **Ganter B., Wille R.: Formal Concept Analysis. Springer, 1999.**

Application of FCA:

-   knowledge extraction
-   clustering and classification
-   machine learning
-   concepts, ontologies
-   rules, association rules, attribute implications

## Background in FCA

FCA provides methods to describe the relationship between a set of objects $G$ and a set of attributes $M$.

We show the main methods of FCA using the main functionalities and data structures of the `fcaR` package.

We load the `fcaR` package by:

```{r }
library(fcaR)
```

Formal Context, $\mathbf{ K} := (G, M, I)$

```{r echo = TRUE}
objects <- c("Mercury", "Venus", "Earth", "Mars",
             "Jupiter", "Saturn", "Uranus", "Neptune",
             "Pluto")

attributes <- c("small", "medium", "large",
                "near", "far",
                "moon", "no_moon")

planets <- matrix(0, nrow = length(objects),
                  ncol = length(attributes))

rownames(planets) <- objects
colnames(planets) <- attributes

planets["Mercury", c("small", "near", "no_moon")] <- 1
planets["Venus", c("small", "near", "no_moon")] <- 1
planets["Earth", c("small", "near", "moon")] <- 1
planets["Mars", c("small", "near", "moon")] <- 1
planets["Jupiter", c("large", "far", "moon")] <- 1
planets["Saturn", c("large", "far", "moon")] <- 1
planets["Uranus", c("medium", "far", "moon")] <- 1
planets["Neptune", c("medium", "far", "moon")] <- 1
planets["Pluto", c("small", "far", "moon")] <- 1
fc_planets <- FormalContext$new(planets)

```

```{r,echo=TRUE}
knitr::kable(planets, format = "html", booktabs = TRUE)
```

Two mappings can be defined:

-   **intent**: $(\ )'\colon 2^G \to 2^M$ with, for all $A\subseteq G$, $A' = \{m \in M \mid g\, I\, m \mbox{ for all } g \in A\}$ for all $A\subseteq G$.

-   **extent**: $(\ )'\colon 2^M \to 2^G$ with, for all $B\subseteq M$, $B' = \{g \in G \mid g\, I\, m \mbox{ for all } m \in B\}$.

That is, the intent of a set of objects is the set of their common attributes:

```{r, echo=TRUE}
# Define a set of objects
S <- Set$new(attributes = fc_planets$objects)
S$assign(Earth = 1, Mars = 1)
cat("Given the set of objects:")
S
cat("The intent is:")

# Compute the intent of S
fc_planets$intent(S)
```

Analogously, the extent of a set of attributes is the set of objects which possess all the attributes in the given set:

```{r, echo=TRUE}
# Define a set of objects
S <- Set$new(attributes = fc_planets$attributes)
S$assign(moon = 1, large = 1)
cat("Given the set of attributes:")
S
cat("The extent is:")

# Compute the extent of S
fc_planets$extent(S)
```

This pair of mappings is a Galois connection.

The composition of intent and extent is the closure of a set of attributes:

```{r, echo=TRUE}
# Compute the closure of S
print("El conjunto de objetos ")
S
print("tiene como cerrado")
Sc <- fc_planets$closure(S)
Sc
```

This means that all planets which have the attributes `moon` and `large` also have `far` in common.

**Definition:** A **formal concept** is a pair $(A,B)$ such that $A \subseteq G$, $B \subseteq M$, $A' = B$ and $B' = A$. Consequently, $A$ and $B$ are closed sets of objects and attributes, respectively.

```{r, echo=TRUE}
# Define a set of objects
S <-  Set$new(attributes = fc_planets$attributes)
S$assign(moon = 1, large = 1, far= 1)
print("Given the set of attributes:")
S
print("The extent is:")

# Compute the extent of S
extent <- fc_planets$extent(S)
extent
print("And the intent of this one is:")
fc_planets$intent(extent)

```

$\big(\{Jupiter, Saturn\},\{large, far, moon\}\big)$ is a concept. It is a maximal cluster.

### Datasets

We are going to work with two datasets, a crisp one and a fuzzy one.

The classical (binary) dataset is the well-known `planets` formal context, presented in

> Wille R (1982). "Restructuring Lattice Theory: An Approach Based on Hierarchies of Concepts." In Ordered Sets, pp. 445--470. Springer.

```{r}
objects <- c("Mercury", "Venus", "Earth", "Mars",
             "Jupiter", "Saturn", "Uranus", "Neptune",
             "Pluto")

attributes <- c("small", "medium", "large",
                "near", "far",
                "moon", "no_moon")

planets <- matrix(0, nrow = length(objects),
                  ncol = length(attributes))

rownames(planets) <- objects
colnames(planets) <- attributes

planets["Mercury", c("small", "near", "no_moon")] <- 1
planets["Venus", c("small", "near", "no_moon")] <- 1
planets["Earth", c("small", "near", "moon")] <- 1
planets["Mars", c("small", "near", "moon")] <- 1
planets["Jupiter", c("large", "far", "moon")] <- 1
planets["Saturn", c("large", "far", "moon")] <- 1
planets["Uranus", c("medium", "far", "moon")] <- 1
planets["Neptune", c("medium", "far", "moon")] <- 1
planets["Pluto", c("small", "far", "moon")] <- 1
```

```{r}
knitr::kable(planets, format = "html", booktabs = TRUE)
```

The other formal context is fuzzy and is defined by the following matrix I:

```{r }
objects <- paste0("O", 1:6)
n_objects <- length(objects)

attributes <- paste0("P", 1:6)
n_attributes <- length(attributes)

I <- matrix(data = c(0, 1, 0.5, 0, 0, 0.5,
                     0, 1, 0.5, 0, 0, 0.5,
                     0.5, 1, 0, 0, 1, 0,
                     0.5, 0, 0, 1, 0.5, 0,
                     1, 0, 0, 0.5, 0, 0,
                     0, 0, 1, 0, 0, 1),
            nrow = n_objects,
            byrow = FALSE)

colnames(I) <- attributes
rownames(I) <- objects
fc_planets <- FormalContext$new(planets)
fc_I <- FormalContext$new(I)
```

```{r}
knitr::kable(I, format = "html", booktabs = TRUE)
```

## Working with Formal Contexts - datasets

The first step when using the `fcaR` package to analyse a formal context is to create an object of class `FormalContext` which will store all the information related to the context.

In our examples, we create two objects:

```{r}
fc_planets <- FormalContext$new(planets)
fc_I <- FormalContext$new(I)
```

Internally, the object stores information about whether the context is binary or the names of objects and attributes, which are taken from the rownames and colnames of the provided matrix.

### Plotting, printing and latex-ing the FormalContext

Once created the `FormalContext` objects, we can print them or plot them as heatmaps (with functions `print()` and `plot()`):

```{r}
print(fc_planets)
print(fc_I)
```

```{r fig.dim=c(4,4)}
fc_planets$plot()
fc_I$plot()
```

Also, we can export the formal context as a LaTeX table:

```{r}
fc_planets$to_latex()
```

### Closures

The basic operation in FCA is the computation of closures given an attribute set, by using the two derivation operators, extent and intent.

The intent of a (probably fuzzy) set of objects is the set of their common attributes:

```{r}
# Define a set of objects
S <-  Set$new(attributes = fc_planets$objects)
S$assign(Earth = 1, Mars = 1)
S

# Compute the intent of S
fc_planets$intent(S)
```

Analogously, the extent of a set of attributes is the set of objects which possess all the attributes in the given set:

```{r}
# Define a set of objects
S <- Set$new(attributes = fc_planets$attributes)
S$assign(moon = 1, large = 1)
S

# Compute the extent of S
fc_planets$extent(S)
```

The composition of intent and extent is the closure of a set of attributes:

```{r}
# Compute the closure of S
Sc <- fc_planets$closure(S)
Sc
```

This means that all planets which have the attributes `moon` and `large` also have `far` in common.

We can check whether a set is closed (that is, it is equal to its closure), using `is_closed()`:

```{r}
fc_planets$is_closed(S)
fc_planets$is_closed(Sc)
```

### Clarification and Reduction

An interesting point when managing formal contexts is the ability to reduce the context, removing redundancies, while retaining all the knowledge. This is accomplished by two functions: `clarify()`, which removes duplicated attributes and objects (columns and rows in the original matrix); and `reduce()`, which uses closures to remove dependent attributes, but only on binary formal contexts. The resulting `FormalContext` is equivalent to the original one in both cases.

```{r}
fc_planets$reduce(TRUE)

fc_I$clarify(TRUE)
```

Note that merged attributes or objects are stored in the new formal context by using squared brackets to unify them, e.g. `[Mercury, Venus]`.

### Extracting Implications and Concepts

The function to extract the canonical basis of implications and the concept lattice is `find_implications()`. Its use is to store a `ConceptLattice` and an `ImplicationSet` objects internally in the `FormalContext` object after running the NextClosure algorithm.

It can be used both for binary and fuzzy formal contexts, resulting in binary or fuzzy concepts and implications:

```{r}
fc_planets$find_implications()

fc_I$find_implications()
```

We can inspect the results as:

```{r}
# Concepts
fc_planets$concepts

# Implications
fc_planets$implications
```

<!-- ## Standard Context -->

<!-- Once we have computed the concepts, we can build the _standard context_ (J, M, $\le$), where J is the set of join-irreducible concepts and M are the meet-irreducible ones. Join and meet are another name for supremum and infimum operations in the concept lattice. -->

<!-- The function `standardize()` works for all FormalContext where the concept lattice has been found, and it produces a new `FormalContext` object: -->

<!-- ```{r} -->

<!-- fc_planets$standardize() -->

<!-- fc_I$standardize() -->

<!-- ``` -->

<!-- Note that now objects are named J1, J2... and attributes are M1, M2..., from join and meet. -->

### Saving and loading

A `FormalContext` is saved and loaded (in RDS format) using its own methods `save()` and `load()`, which are more efficient than the base `saveRDS()` and `readRDS()`.

```{r eval = FALSE}
fc$save(filename = "./fc.rds")

# Create an empty FormalContext where to
# import the previously saved
fc2 <- FormalContext$new()
fc2$load("./fc.rds")
```

## Concept Lattice

We are going to use the previously computed concept lattices for the two `FormalContext` objects.

### Plot, print and LaTeX

The concept lattice can be plotted using a Hasse diagram and the function `plot()` inside the `ConceptLattice` component:

```{r}
fc_planets$concepts$plot()
fc_I$concepts$plot()
```

If one desires to get the list of concepts printed, or in $\LaTeX$ format, just:

```{r}
# Printing
fc_planets$concepts

# LaTeX
fc_planets$concepts$to_latex()
```

### Getting all extents, intents and retrieving concepts

For a `ConceptLattice`, one may want to retrieve particular concepts, using a subsetting as in `R`:

```{r}
fc_planets$concepts[2:3]
```

Or get all the extents and all the intents of all concepts, as sparse matrices:

```{r eval = TRUE}
fc_planets$concepts$extents()
fc_planets$concepts$intents()
```

### Concept support

First, the support of an itemset is:

$$
supp(X)=\frac{X^\prime}{G}
$$

The support of a concept \$\\langle A, B\\rangle\$ (A is the extent of the concept and B is the intent) is the cardinality (relative) of the extent - number of objects of the extent.

The support of concepts can be computed using the function `support()`:

```{r}
fc_planets$concepts$support()
```

The support of itemsets and concepts is used to mine all the knowledge: Algorithm Titanic (computing iceberg concept lattices)

### Sublattices

When the concept lattice is too large, it can be useful in certain occasions to just work with a sublattice of the complete lattice. To this end, we use the `sublattice()` function.

For instance, to build the sublattice of those concepts with support greater than 0.5, we can do:

```{r}
# Get the index of those concepts with support 
# greater than the threshold
idx <- which(fc_I$concepts$support() > 0.2)
# Build the sublattice
sublattice <- fc_I$concepts$sublattice(idx)
sublattice
```

And we can plot just the sublattice:

```{r}
sublattice$plot()
```

### Subconcepts, superconcepts, infimum and supremum

It may be interesting to use the notions of subconcept and superconcept. Given a concept, we can compute all its subconcepts and all its superconcepts:

```{r}
# The fifth concept
C <- fc_planets$concepts[5]
C
# Its subconcepts:
fc_planets$concepts$subconcepts(C)
# And its superconcepts:
fc_planets$concepts$superconcepts(C)
```

Also, we can define infimum and supremum of a set of concepts as the greatest common subconcept of all the given concepts, and the lowest common superconcept of them, and can be computed by:

```{r}
# A list of concepts
C <- fc_planets$concepts[5:7]
C

# Supremum of the concepts in C
fc_planets$concepts$supremum(C)
# Infimum of the concepts in C
fc_planets$concepts$infimum(C)
```

### Join- and meet- irreducible elements

**Theorem:** 

In a complete lattice, an element is called supremum-irreducible or join-irreducible if it cannot be written as the supremum of other elements and infimum-irreducible or meet-irreducible if it can not be expressed as the infimum of other elements.

![](reticulo.png){width="600"}

The irreducible elements with respect to join (supremum) and meet (infimum) can be computed for a given concept lattice:

```{r}
fc_planets$concepts$join_irreducibles()
fc_planets$concepts$meet_irreducibles()
```

This are the concepts used to build the *standard context*, mentioned above.

## Exercises

1) Compute the intent of ``Earth`` and   ``Earth,Mars, Mercury`` (use the argument attributes in the class Set). 

```{r, echo=FALSE}
S <- Set$new(attributes = fc_planets$objects)
S$assign(Earth = 1)
S2 <- Set$new(attributes = fc_planets$objects)
S2$assign(attributes = c("Earth","Mars", "Mercury"),values = c(1,1,1))
S2
cat("Given the set of objects:")
S
cat("The intent is:")
# Compute the intent of S
fc_planets$intent(S)
fc_planets$intent(S2)


```

2) Compute the extent of ``large`` and   ``far,large
`` (use the argument attributes in the class Set) and save the result in a variable `e1, e2`. 

```{r, echo=FALSE}
M <- Set$new(attributes = fc_planets$attributes)
M$assign(large = 1)
M2 <- Set$new(attributes = fc_planets$attributes)
M2$assign(attributes = c("far","large"),values = c(1,1))
cat("Given the set of objects:")
M
M2
cat("The extent is:")
# Compute the intent of S
e1 <- fc_planets$extent(M)
e2 <- fc_planets$extent(M2)
e1
e2
```

2) Compute the intent of  variables `e1`  and also of `e2`. 
```{r, echo=FALSE}
fc_planets$intent(e1)
fc_planets$intent(e2)

```


3) With the information from the above questions tell me a concept. Check with any command of fcaR package. 

4) Compute the closure of ``no_moon`` 

```{r, echo=FALSE}
S <- Set$new(attributes = fc_planets$attributes)
S$assign(no_moon = 1)
Sc <- fc_planets$closure(S)
Sc

fc_planets$att_concept("moon")
```

5) Compute all the  concepts and plot them. How many are there?  Show the fist and the last (use subsetting).

```{r, echo=FALSE}
fc_planets$find_concepts()
last <- fc_planets$concepts$size()
fc_planets$concepts[c(1,last)]
fc_planets$concepts$plot()
```

6) Compute the major concept (in lattice) that has  moon. The same with no_moon. Locate both in the lattice to understand the meaning. 

```{r, echo=FALSE}
fc_planets$att_concept("moon")
fc_planets$att_concept("no_moon")

```

7) Compute the minor concept (in lattice) that has  Pluto The same with Earth. Locate both in the lattice to understand the meaning. 

```{r, echo=FALSE}
fc_planets$obj_concept("Pluto")
fc_planets$obj_concept("Earth")

```


8) Compute the meet irreducible elements in the lattice. 

```{r, echo=FALSE}
fc_planets$concepts$meet_irreducibles()
 
```


9) Compute the sublattice of the concept in  the irreducible elements

```{r, echo=FALSE}
c1 <-  fc_planets$concepts$meet_irreducibles()
fc_planets$concepts$sublattice(c1)
```


10) Compute the sublattice of the concept in  the irreducible elements removing the first element in the list of irreducible elements. Plot this sublattice.  

```{r, echo=FALSE}
c1 <-  fc_planets$concepts$meet_irreducibles()[2:7]
sub1 <- fc_planets$concepts$sublattice(c1)
sub1
plot(sub1)
```

   
11) Develop a function returning the index and also the labels in     all the concepts (inside the formal context) having a vector with  attributes. HOMEWORK.  

```{r}
in_concept <- function(formal_context, attribute=xxx){
  ...
  #si en 
  
  return(list(index=..., labels=...))
}
 

```


## Implications in FCA

This is a summary of some of the functionalities introduced in package `fcaR`:

- Computing implications and concepts using Ganter's algorithm.
- Visualization of the concept lattice.
- Removal of redundancies in implications.
- Computation of closures.

#### Data

The datasets in this vignette come from [this paper](https://www.sciencedirect.com/science/article/pii/S1877705812021418).

### Crisp Version

The crisp version of the data appears in Table 3 in the mentioned paper.

```{r}
objects <- paste0("O", 1:6)
n_objects <- length(objects)

attributes <- paste0("P", 1:6)
n_attributes <- length(attributes)

I <- matrix(data = c(0, 1, 1, 0, 0, 1,
                     1, 1, 1, 0, 0, 0,
                     1, 1, 0, 0, 1, 0,
                     1, 0, 0, 1, 1, 0,
                     1, 0, 0, 1, 0, 0,
                     0, 0, 1, 0, 0, 0),
            nrow = n_objects,
            byrow = FALSE)

colnames(I) <- attributes
rownames(I) <- objects
```

### Computing Implications and Concepts

Once we create the formal context object, with the previous data matrix I, we can compute all concepts and implications using Ganter's algorithm:
```{r}
fc <- FormalContext$new(I)

# Compute implications
fc$find_implications(verbose = FALSE)

# Cardinality and mean size in the ruleset
fc$implications$cardinality()
sizes <- fc$implications$size()
colMeans(sizes)
```

The obtained implications are:
```{r}
fc$implications
```

#### Visualization

We provide functions to plot both the concept lattice and the formal context:

```{r fig.width=7.5}
# Visualize the concept lattice
fc$concepts$plot()
# And the formal context
fc$plot()
```

### Redudancy Removal

Let us apply some simplifcation rules:
```{r}
fc$implications$apply_rules(rules = c("composition",
                                      "generalization",
                                      "simplification"),
                            parallelize = FALSE)

# Compute cardinality and size in the transformed ruleset:
fc$implications$cardinality()
sizes <- fc$implications$size()
colMeans(sizes)
```

The transformed ruleset:
```{r}
fc$implications
```

### Fuzzy version

The fuzzy version of the data appears in Table 2 in the mentioned paper.

```{r}
objects <- paste0("O", 1:6)
n_objects <- length(objects)

attributes <- paste0("P", 1:6)
n_attributes <- length(attributes)

I <- matrix(data = c(0, 1, 0.5, 0, 0, 0.5,
                     1, 1, 0.5, 0, 0, 0,
                     0.5, 1, 0, 0, 1, 0,
                     0.5, 0, 0, 1, 0.5, 0,
                     1, 0, 0, 0.5, 0, 0,
                     0, 0, 1, 0, 0, 0),
            nrow = n_objects,
            byrow = FALSE)

colnames(I) <- attributes
rownames(I) <- objects
```

#### Computing Implications and Concepts

As before, we build the formal context object and compute all implications:

```{r}
fc <- FormalContext$new(I)

# Compute
fc$find_implications(verbose = FALSE)

# Some properties of the ruleset
fc$implications$cardinality()
sizes <- fc$implications$size()
colMeans(sizes)
```

The extracted ruleset is:
```{r}
fc$implications
```

#### Visualization

Let us plot the concept lattice and the formal context.
```{r fig.width=7.5}
# Visualize the concept lattice
fc$concepts$plot()
# And the formal context
fc$plot()
```

#### Redudancy Removal

Let us apply some functions to remove redudancies in the set of implications:

```{r}
fc$implications$apply_rules(rules = c("composition"), 
                            reorder = FALSE,
                            parallelize = FALSE)
fc$implications$cardinality()
sizes <- fc$implications$size()
colMeans(sizes)

fc$implications$apply_rules(rules = c("simplification"), 
                            reorder = FALSE,
                            parallelize = FALSE)
fc$implications$cardinality()
sizes <- fc$implications$size()
colMeans(sizes)

fc$implications$apply_rules(rules = c("generalization"), 
                            reorder = FALSE,
                            parallelize = FALSE)

fc$implications$cardinality()
sizes <- fc$implications$size()
colMeans(sizes)
```

The reduced ruleset is:
```{r}
fc$implications
```

#### Closures

Let us show how to compute the closure of a set S with respect to the implication set.
```{r}
S <-  Set$new(attributes = fc$attributes)
S$assign(P2 = 0.5, P3 = 0.5)
S

fc$implications$closure(S)
```


## Exercise


- From an implication extracted from a formal cotext return the string representig the implication: 

```

> cadena <- impl.as.character(Implication)
> cadena
> "a,b ->  c,d"

```

Use  the function:

```
impl.as.character <- function(Implication ){

  xxxx

return{cadena}


}

```



- From a string  add the implication represented in the string to an implicational set:

```
cadena <- "a,b ->  c,d"
implicationsNew <- add_implication(cadena,Implications)
```

Use  the function:

```
add_implication <- function(stringImplication,ImplicationSet){

  xxxx

return{ImplicationSetNew}


}

```

   
   
## Simplification Logic for Mushroom Dataset"
 

This is a simple example of some of the functionalities introduced in package `fcaR`:

- Import from/export to `arules` format.
- Removal of redundancies in implications.
- Computation of closures.

### Data

In this example, we'll use the well-known [_Mushroom_ dataset](http://archive.ics.uci.edu/ml/datasets/Mushroom), from the `arules` package. 

We'll use the _a priori_ algorithm to extract a large number of implications from the dataset.

```{r}
library(arules)

data("Mushroom", package = "arules")

mush <- apriori(Mushroom, parameter = list(conf = 1))
```

The number of implications extracted by the algorithm (with this configuration) is `length(mush) = ` `r length(mush)`.

### Preprocessing

Next step is to remove the redundant rules in the implications set. To this end, let us use the `is.redundant()` function in `arules`.

```{r}
system.time(
  idx_redundant <- is.redundant(mush)
)

mush_clean <- mush[!idx_redundant]
```
After this, the number of implications is `length(mush_clean) = ` `r length(mush_clean)`, that is, just a `r round(length(mush_clean) / length(mush) * 100, 3)` percent of the original ruleset.

### Importing in fcaR

To use the functionalities in this package, one must import all objects (the formal context and implications above) into our data model.

This is accomplished by just typing:
```{r}
fc <- FormalContext$new(I = Mushroom)

fc$implications$add(mush_clean)
```

We can check some of the properties of the ruleset:

```{r}
# Cadinality
fc$implications$cardinality()

# Rule size
sizes <- fc$implications$size()

# Mean size for LHS and RHS
colMeans(sizes)
```

### Applying Rules

We can improve the redudancy removal performed by `arules`, using some simplification rules. Currently, the following rules are implemented:

- Composition.
- Generalization.
- Simplification.
- R-Simplification

We can apply them one by one, just to see their effect, or we could use them sequentially.

```{r}
# Use composition to reduce the number of implications
fc$implications$apply_rules(rules = c("composition"),
                            parallelize = FALSE)

fc$implications$cardinality()
sizes <- fc$implications$size()
colMeans(sizes)

 

# At this moment, we're at a fixed point, but we could apply
# some more rules if needed:
fc$implications$apply_rules(rules = c("composition",
                                      "generalization",
                                      "simplification",
                                      "rsimplification"),
                            parallelize = FALSE)
```



```{r}
# Cadinality
fc$implications$cardinality()

# Rule size
sizes <- fc$implications$size()

# Mean size for LHS and RHS
colMeans(sizes)
```


Also, we can compute the support of each implication:
```{r}
supp <- fc$implications$support()

head(supp)
```


### Computing Closure

Given a fuzzy set represented by a sparse matrix, we can compute its closure with respect to the implications in the ruleset.

```{r}
# A fuzzy set
A <-  Set$new(attributes = fc$attributes)
A$assign("CapColor=white" = 1)

# Compute the closure
fc$implications$closure(A)

```


### Re-Exporting to `arules`

After this phase of redudancy removal, we can export the obtained ruleset to `arules` format.

```{r}
R <- fc$implications$to_arules()

R

class(R)
```

   